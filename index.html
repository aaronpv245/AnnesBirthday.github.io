<!--
    Webpage layout (HTML classes/IDs)

    +-------------------------------------------------------------+
    | .header-group                                               |
    +-------------------------------------------------------------+
    | #main-container                                             |
    |  +-------------------------------------------------------+  |
    |  | .bingo-grid (7x7 cells)                               |  |
    |  |   - Interactive cells, persisted in localStorage      |  |
    |  +-------------------------------------------------------+  |
    |  | .controls (Reset, Share, Export buttons)              |  |
    |  +-------------------------------------------------------+  |
    |  | #patternCanvas (background canvas, decorative)        |  |
    +-------------------------------------------------------------+
    | .footer (attribution, copyright)                            |
    +-------------------------------------------------------------+
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anne's Birthday Bingo</title>
    <!-- Import a font that matches the Royal Copenhagen vibe -->
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #ffffff;
            font-family: 'Playfair Display', serif;
            /* Allow scrolling when the scaled app is larger than viewport */
            overflow: auto;
            display: flex;
            /* anchor app to top so header remains visible when scaling up */
            align-items: flex-start;
            justify-content: center;
            /* small top/bottom padding so scrolling isn't flush to edges */
            padding: 20px 0 40px;
        }

        /* Moved from inline CSS in pubs panel h2 */
        .pubs-title {
            margin-top: 0;
            color: #1a45a0;
        }

        /* --- THE SCALING CONTAINER --- 
           Everything lives in here. We design for a fixed "Base Resolution"
           of roughly 1000px x 1000px, and then JS scales this entire div 
           to fit the screen. 
        */
        #main-container {
            position: relative;
            width: 1000px;
            height: 1000px;
            display: flex;
            align-items: center;
            justify-content: center;
            /* scale from the top so the title stays visible when page grows */
            transform-origin: top center;
        }

        /* --- BACKGROUND CANVAS --- 
           Now absolute INSIDE the container so it scales with it.
        */
        canvas {
            display: block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 0;
            pointer-events: none; 
        }

        /* --- HEADERS (Positioned relative to container center) --- */
        .header-group {
            position: absolute;
            /* Positioned above the 600px vine square (which starts at y=200px relative to container) */
            top: 30px; 
            left: 50%;
            transform: translateX(-50%);
            width: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 2;
        }

        h1 {
            color: #1a45a0;
            font-size: 4rem;
            margin: 0 0 12px 0; /* Spacing below title */
            text-shadow: 3px 3px 0px #fff, -1px -1px 0 #fff;
            font-style: italic;
            white-space: nowrap;
        }

        .tabs {
            display: flex;
            gap: 12px;
            flex-wrap: nowrap;
            justify-content: center;
            align-items: center;
            white-space: nowrap;
        }

        /* --- ORGANIC GRID --- */
        .bingo-grid {
            position: absolute;
            /* Centering the grid perfectly in the container */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            /* 460px fits inside the 600px vine square */
            width: 460px; 
            height: 460px;
        }

        .bingo-cell {
            background: rgba(255, 255, 255, 0.92);
            border: 1.5px solid #1a45a0;
            color: #1a45a0;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 2px;
            font-size: 0.7rem; 
            line-height: 1.1;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.15s ease, background 0.15s ease;
            /* ensure pseudo-element anchors to the cell so it scales uniformly */
            position: relative;
            /* cross-browser no-select */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-user-select: none;
            -webkit-user-select: none;
            user-select: none;
            box-shadow: 2px 2px 4px rgba(26, 69, 160, 0.15);
            /* Initial organic radius - JS adds variety */
            border-radius: 15px; 
        }

        .bingo-cell:hover {
            transform: scale(1.15);
            background: #fff;
            z-index: 10;
            border-color: #123275;
            box-shadow: 4px 4px 8px rgba(26, 69, 160, 0.25);
        }

        /* Selected State */
        .bingo-cell.checked {
            background-color: #1a45a0;
            color: white;
            border-color: #123275;
            box-shadow: inset 1px 1px 3px rgba(0,0,0,0.3);
        }

        .bingo-cell.checked::after {
            content: "✓";
            position: absolute;
            font-size: 1.8rem;
            color: rgba(255,255,255,0.5);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-10deg);
        }

        .bingo-cell.center-cell {
            font-size: 0.85rem;
        }

        /* --- CONTROLS --- */
        .controls {
            position: absolute;
            /* Pushes button down below the grid and vines */
            top: 50%;
            margin-top: 400px; 
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 2;
            width: 100%;
        }

        button.reset-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #1a45a0;
            color: #1a45a0;
            padding: 12px 35px;
            font-family: 'Playfair Display', serif;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            border-radius: 255px 15px 225px 15px / 15px 225px 15px 255px;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        button.reset-btn:hover {
            background: #1a45a0;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.15);
        }

        /* Tabs */
        .tab-btn {
            background: rgba(255,255,255,0.95);
            border: 1px solid #dfe8ff;
            color: #123275;
            padding: 8px 14px;
            border-radius: 999px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(17,35,90,0.04);
            white-space: nowrap;
            flex-shrink: 0;
        }
        .tab-btn.active { background: #1a45a0; color: white; border-color: #123275; }

        .tab-content { display: block; }
        .hidden { display: none !important; }

        /* Centered content that aligns with the decorative square (matches CONFIG.squareSize) */
        .centered-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            width: 600px; /* matches CONFIG.squareSize */
            max-width: 90%;
            box-sizing: border-box;
            pointer-events: auto;
        }

        /* counter-scale prevents the pubs text from inheriting the global app scale */
        .counter-scale {
            transform-origin: top center;
        }

        /* Pub checkbox — small variant of bingo cell */
        /* make each list item a clear row with spacing and centered checkbox */
        #pubsList { list-style: none; padding: 0; margin: 0; }
        .pub-row {
            display: flex;
            align-items: center;        /* center checkbox next to multi-line text */
            justify-content: space-between;
            padding: 10px 12px;        /* spacing inside each row */
            margin-bottom: 10px;       /* space between rows */
            border-radius: 12px;
            background: rgba(255,255,255,0.98);
            box-shadow: 0 2px 6px rgba(17,35,90,0.02);
        }
        /* replaced flex gap with explicit label margin for Safari compatibility */
        .pub-label {
            flex: 1 1 auto;
            margin: 0;
            margin-right: 14px;
            line-height: 1.35;
            word-break: break-word;
        }
        .pub-checkbox {
            flex: 0 0 46px;
            height: 46px;
            border-radius: 12px;
            background: rgba(255,255,255,0.95);
            border: 1.5px solid #1a45a0;
            color: #1a45a0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            position: relative;
            box-shadow: 2px 2px 4px rgba(26,69,160,0.12);
            transition: transform 0.12s ease, background 0.12s;

            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .pub-checkbox.checked {
            background: #1a45a0;
            color: white;
            border-color: #123275;
            box-shadow: inset 1px 1px 3px rgba(0,0,0,0.25);
        }
        .pub-checkbox::after {
            content: "✓";
            position: absolute;
            font-size: 1.1rem;
            opacity: 0;
            transition: opacity 0.12s;
        }
        .pub-checkbox.checked::after { opacity: 1; color: rgba(255,255,255,0.95); }
 
        /* Ensure the pubs panel fits inside the decorative square and scrolls if needed */
        .pubs-panel {
            /* Responsive: scale to device width, capped at design size */
            width: min(90vw, 368px);
            /* Allow vertical growth but cap to viewport for mobile usability */
            max-height: min(75vh, 368px);
            overflow: auto;
            margin: 0 auto;
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 18px;
            border: 1px solid #e6e9ff;
            box-shadow: 0 6px 14px rgba(17,35,90,0.06);
            box-sizing: border-box;
        }

        /* Welcome Banner */
        .welcome-banner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.97);
            color: #1a45a0;
            padding: 50px 60px;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(26, 69, 160, 0.25);
            border: 2px solid #1a45a0;
            border-radius: 20px;
            font-family: 'Playfair Display', serif;
            max-width: 600px;
            width: 90%;
        }

        .welcome-banner::before,
        .welcome-banner::after {
            content: "";
            position: absolute;
            font-size: 3rem;
            opacity: 0.7;
            top: 20px;
        }

        .welcome-banner::before {
            left: 20px;
        }

        .welcome-banner::after {
            right: 20px;
        }

        .welcome-banner h2 {
            margin: 0 0 15px 0;
            font-size: 2.5rem;
            font-style: italic;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .welcome-banner p {
            margin: 0 0 25px 0;
            font-size: 1.3rem;
            font-weight: 400;
            letter-spacing: 0.5px;
            line-height: 1.4;
        }

        .welcome-banner button {
            background: #1a45a0;
            color: white;
            border: 2px solid #1a45a0;
            padding: 12px 40px;
            border-radius: 999px;
            cursor: pointer;
            font-weight: bold;
            font-family: 'Playfair Display', serif;
            font-size: 1.1rem;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(26, 69, 160, 0.2);
        }

        .welcome-banner button:hover {
            background: white;
            color: #1a45a0;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(26, 69, 160, 0.3);
        }

        .welcome-banner.hidden {
            display: none;
        }

        /* Blur content when banner is active */
        #main-container.banner-active {
            filter: blur(5px);
            pointer-events: none;
        }

        .header-group.banner-active {
            filter: blur(5px);
            pointer-events: none;
        }
 
    </style>
</head>
<body>

<!-- Welcome Banner -->
<div id="welcomeBanner" class="welcome-banner">
    <h2>Welcome!</h2>
    <p>Join Anne's Birthday Celebration!</p>
    <button onclick="dismissWelcome()">Let's Go!</button>
</div>

<!-- Unified Container for Scaling -->
<main id="main-container">
    
    <!-- Background Pattern -->
    <canvas id="patternCanvas"></canvas>

    <!-- Headers -->
    <header class="header-group">
        <h1>Anne's Birthday</h1>
        <div class="tabs" role="tablist">
            <button class="tab-btn active" data-tab="pubs" role="tab" aria-selected="true" aria-controls="pubsContent">12 Pubs of Christmas</button> 
            <button class="tab-btn" data-tab="bingo" role="tab" aria-selected="false" aria-controls="bingoContent">Pub Crawl Bingo</button>
        </div>
    </header>
    
    <!-- Tabbed Content: Bingo (default) -->
    <div id="bingoContent" class="tab-content" role="tabpanel" aria-labelledby="tab-bingo">
        <!-- Grid -->
        <div class="bingo-grid" id="grid"></div>

        <!-- Controls -->
        <div class="controls">
            <button class="reset-btn" id="reset-btn">Reset Board</button>
        </div>
    </div>

    <!-- Tabbed Content: 12 Pubs of Christmas -->
    <div id="pubsContent" class="tab-content hidden" role="tabpanel" aria-labelledby="tab-pubs">
        <!-- centered-content is counter-scaled so it keeps centered position regardless of zoom -->
        <div class="centered-content counter-scale">
            <div class="pubs-panel" id="pubsPanel">
                <h2 class="pubs-title">12 Pubs of Christmas — Nick Miller edition</h2>
                <p><strong>Overall rule:</strong> Respect the crawl. Any disrespect and you drink. When someone says '29' (The Schmidt way), everyone must drink.</p>
                <p><strong>START:</strong> 3.30pm</p>

                <ol id="pubsList">
                    <li><strong>Pub 1:</strong> 67A Tabley Road — <em>The Oracle</em>: Abs becomes the Oracle and must make predictions about the rest of the night. If anyone challenges the Oracle, they must take a sip.</li>
                    <li><strong>Pub 2:</strong> The Prince Edward, 38 Parkhurst Rd, London N7 0SF — <em>Nick Miller cheapskate rule</em>: Everyone must buy the cheapest drink on the menu. If you fail to do so, or try to upgrade, you have to tell the group a secret you’ve never shared before.</li>
                    <li><strong>Pub 3:</strong> The Crown, 622 Holloway Rd, Archway, London N19 3PA — <em>The crawl doesn’t wait rule</em>: Once one person finishes their drink, we must move to the next pub within 2 minutes.</li>
                    <li><strong>Pub 4:</strong> The Landseer Arms, 37 Landseer Rd, London N19 4JU — <em>The Schmidt sentimental rule</em>: Before your first sip, everyone must say one sincere, borderline dramatic compliment about me. If it’s too vague, you have to finish your drink.</li>
                    <li><strong>Pub 5:</strong> The Swimmer at the Grafton Arms, 13 Eburne Rd, London N7 6AR — <em>The guide rule</em>: Diana must lead the group with blind confidence and 0 navigation skills to this pub. If we get lost, everyone drinks.</li>
                    <li><strong>BUS BREAK</strong> aka <em>BUZZBALL BREAK</em></li>
                    <li><strong>Pub 6:</strong> The Red Lion, 132 Stoke Newington Church St, London N16 0JX — <em>The crawl demands a sacrifice rule</em>: Each person must give up one thing for the pub i.e. no drinking with your dominant hand, no straw, no smiling. If you break your rule, you have to take a sip.</li>
                    <li><strong>Pub 7:</strong> The Auld Shillelagh, 105 Stoke Newington Church St, London N16 0UD — <em>The Cece and Jess rage rule</em>: Only drinks over 20% allowed and you must say one mildly unhinged sentence about an ex, situationship or work injustice.</li>
                    <li><strong>Pub 8:</strong> Three Crowns, 175 Stoke Newington High St, London N16 0LH — <em>The Nick Miller spiral rule</em>: Everyone must share a wildly disproportionate worry, and it has to be over something tiny. If it’s actually reasonable, you must drink.</li>
                    <li><strong>Pub 9:</strong> The Coach & Horses, 178 Stoke Newington High St, London N16 7JL — <em>The Schmidt confidence rule</em>: Everyone must refer to themselves in the 3rd person.</li>
                    <li><strong>Pub 10:</strong> The Rochester Castle, 143-145 Stoke Newington High St, London N16 0NY — <em>The Nick Miller zombie novel rule</em>: Everyone must share a personal dream they once abandoned.</li>
                    <li><strong>Pub 11:</strong> The White Hart, 69 Stoke Newington High St, London N16 8EL — <em>The Tilly is Winston rule</em>: She must declare a completely pointless, overly intense challenge for the pub. Everyone has to commit; if you refuse or break the rule, you have to finish your drink.</li>
                    <li><strong>Pub 12:</strong> Yucatan Bar, 121 Stoke Newington Rd, London N16 8BT — <em>The respect the crawl finale rule</em>: Everyone...</li>
                </ol>

                
            </div>
        </div>
    </div>

</main>

<script>
    /* -----------------------------------------------------------
       WELCOME BANNER
       ----------------------------------------------------------- */
    function dismissWelcome() {
        const banner = document.getElementById('welcomeBanner');
        const mainContainer = document.getElementById('main-container');
        const headerGroup = document.querySelector('.header-group');
        if (banner) {
            banner.classList.add('hidden');
        }
        if (mainContainer) {
            mainContainer.classList.remove('banner-active');
        }
        if (headerGroup) {
            headerGroup.classList.remove('banner-active');
        }
    }

    // Add blur effect on page load when banner is shown
    window.addEventListener('load', () => {
        const mainContainer = document.getElementById('main-container');
        const headerGroup = document.querySelector('.header-group');
        if (mainContainer) {
            mainContainer.classList.add('banner-active');
        }
        if (headerGroup) {
            headerGroup.classList.add('banner-active');
        }
    });

    /* -----------------------------------------------------------
       SCALING LOGIC
       ----------------------------------------------------------- */
    const container = document.getElementById('main-container');
    const counterElements = document.querySelectorAll('.counter-scale');
    
    function resizeApp() {
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const targetWidth = 800; // Our base design width
        const targetHeight = 800; // Our base design height

        // Determine scale to fit within viewport with some padding
        const scaleX = (windowWidth - 20) / targetWidth;
        const scaleY = (windowHeight - 20) / targetHeight;
        const scale = Math.min(scaleX, scaleY); // Fit to smallest dimension

        // set both standard and webkit transform for Safari compatibility
        const scaleStr = `scale(${scale})`;
        container.style.transform = scaleStr;
        container.style.webkitTransform = scaleStr;

        // Apply inverse scale to elements that should remain readable/constant width
        const inv = isFinite(scale) && scale > 0 ? (1 / scale) : 1;
        // NodeList may not support forEach in older Safari; use a simple loop
        for (let i = 0; i < counterElements.length; i++) {
            const el = counterElements[i];
            const t = `translate(-50%, -50%) scale(${inv})`;
            el.style.transform = t;
            el.style.webkitTransform = t;
        }
    }

    window.addEventListener('resize', resizeApp);
    resizeApp(); // Trigger immediately
    // ensure inverse scale also applied after initial layout (fonts may change)
    window.addEventListener('load', resizeApp);

    // Tab switching for additional pages
    function showTab(name) {
        const tabs = document.querySelectorAll('[role="tab"]');
        tabs.forEach(btn => {
            const isActive = btn.dataset.tab === name;
            btn.classList.toggle('active', isActive);
            btn.setAttribute('aria-selected', isActive);
        });

        const bingoEl = document.getElementById('bingoContent');
        const pubsEl = document.getElementById('pubsContent');

        if (name === 'bingo') {
            if (bingoEl) bingoEl.classList.remove('hidden');
            if (pubsEl) pubsEl.classList.add('hidden');
        } else if (name === 'pubs') {
            if (pubsEl) pubsEl.classList.remove('hidden');
            if (bingoEl) bingoEl.classList.add('hidden');
        }
    }

    // Attach tab click listeners
    document.querySelectorAll('[role="tab"]').forEach(btn => {
        btn.addEventListener('click', () => showTab(btn.dataset.tab));
    });

    // Attach reset button listener
    const resetBtn = document.getElementById('reset-btn');
    if (resetBtn) {
        resetBtn.addEventListener('click', resetBingo);
    }


    /* -----------------------------------------------------------
       BINGO LOGIC
       ----------------------------------------------------------- */
    
    const BINGO_TASKS = [
        "Take a shot with Anne", "Spot a cute Dog", "Drink Water!", "ID Check", "Spill a Drink", "Group Selfie", "Toilet Selfie",
        "Eat a Fry", "Hear 'I love this song!'", "Stranger says HBD", "Lose the Group", "Find the Group", "Text an Ex", "Karaoke Moment",
        "Bartender's Choice", "Drink a Stout", "Drink a Lager", "Drink a Cider", "Drink a Cocktail", "Buy Anne a Drink", "Compliment Stranger",
        "Toast Speech", "Glass Break Sound", "Happy Tears", "Piggyback Ride", "Propose a Toast", "High Five Bouncer", "Irish Exit Spotted",
        "Wrong Pub Entered", "Walk in Rain", "One more drink...", "Order Pizza", "Shoe Untied", "Phone Dies", "Borrow Charger",
        "Spot a Mullet", "Wear a Hat", "Someone Trips", "Get a Free Drink", "Jagerbomb!", "Baby Guinness", "Tequila!",
        "Dance Off", "Request a Song", "Hug Anne", "Anne Laughs", "Photo with Anne", "Pet a Pub Dog", "Survive the Night"
    ];

    const STORAGE_KEY = 'anne_bingo_state_v2';

    function loadState() {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
            return JSON.parse(saved);
        }
        return new Array(49).fill(false);
    }

    function saveState(state) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }

    function initGrid() {
        const gridEl = document.getElementById('grid');
        gridEl.innerHTML = '';

        BINGO_TASKS.forEach((task, index) => {
            const cell = document.createElement('div');
            cell.className = 'bingo-cell';
            cell.id = `cell-${index}`;
            
            // Generate Organic Shape
            const r1 = 200 + Math.random() * 55;
            const r2 = 10 + Math.random() * 30;
            const r3 = 200 + Math.random() * 55;
            const r4 = 10 + Math.random() * 30;
            cell.style.borderRadius = `${r1}px ${r2}px ${r3}px ${r4}px / ${r4}px ${r3}px ${r2}px ${r1}px`;

            cell.innerText = task;

            if (index === 24) { 
                cell.classList.add('center-cell');
            }

            cell.onclick = () => toggleCell(index);
            gridEl.appendChild(cell);
        });

        updateGridUI();
    }

    function updateGridUI() {
        const state = loadState();
        BINGO_TASKS.forEach((_, index) => {
            const cell = document.getElementById(`cell-${index}`);
            if (state[index]) {
                cell.classList.add('checked');
            } else {
                cell.classList.remove('checked');
            }
        });
    }

    function toggleCell(index) {
        const state = loadState();
        state[index] = !state[index];
        saveState(state);
        updateGridUI();
    }

    function resetBingo() {
        if(confirm("Are you sure you want to clear the board and reset progress?")) {
            // Clear specific key
            localStorage.removeItem(STORAGE_KEY);
            // OR clear all if requested: localStorage.clear();
            
            updateGridUI(); // Will revert to default false state
        }
    }

    initGrid();
    // Ensure the default tab is visible on load
    if (typeof showTab === 'function') showTab('pubs');

    /* -----------------------------------------------------------
       PUBS CHECKBOXES + PERSISTENCE
       ----------------------------------------------------------- */
    const PUBS_STORAGE_KEY = 'anne_pubs_state_v1';

    function loadPubsState(count) {
        const saved = localStorage.getItem(PUBS_STORAGE_KEY);
        if (saved) {
            try { const parsed = JSON.parse(saved); if (Array.isArray(parsed)) return parsed; } catch(e){}
        }
        return new Array(count).fill(false);
    }

    function savePubsState(state) {
        localStorage.setItem(PUBS_STORAGE_KEY, JSON.stringify(state));
    }

    function initPubsCheckboxes() {
        const ol = document.getElementById('pubsList');
        if (!ol) return;
        const items = Array.from(ol.querySelectorAll('li'));
        const state = loadPubsState(items.length);

        items.forEach((li, idx) => {
            // wrap content in flex row and append checkbox
            const text = document.createElement('div');
            text.className = 'pub-label';
            // keep the existing innerHTML as label
            text.innerHTML = li.innerHTML;

            const checkbox = document.createElement('button');
            checkbox.type = 'button';
            checkbox.className = 'pub-checkbox';
            checkbox.setAttribute('aria-pressed', state[idx] ? 'true' : 'false');
            checkbox.dataset.index = idx;

            if (state[idx]) checkbox.classList.add('checked');

            checkbox.onclick = () => {
                const s = loadPubsState(items.length);
                s[idx] = !s[idx];
                savePubsState(s);
                checkbox.classList.toggle('checked', s[idx]);
                checkbox.setAttribute('aria-pressed', s[idx] ? 'true' : 'false');
            };

            // replace li content with structured row
            li.innerHTML = '';
            li.classList.add('pub-row');
            li.appendChild(text);
            li.appendChild(checkbox);
        });
    }

    // Initialize pubs checkboxes once DOM is ready
    document.addEventListener('DOMContentLoaded', initPubsCheckboxes);
    // In case script runs after DOMContentLoaded
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        initPubsCheckboxes();
    }
 
    /* -----------------------------------------------------------
       BACKGROUND PATTERN GENERATOR
       ----------------------------------------------------------- */

    const canvas = document.getElementById('patternCanvas');
    const ctx = canvas.getContext('2d');

    // Configuration
    const CONFIG = {
        color: '#1a45a0', 
        detailColor: '#123275',
        flowerColor: '#2b5bbd', 
        lineWidth: 0.6, 
        // Align sheet to the app base resolution so the canvas visuals scale exactly with the container
        sheetSize: 1000,
        squareSize: 600, 
        sway: 60,
        layoutSeed: 111,
        skippedElements: []
    };

    let _seed = CONFIG.layoutSeed;
    function layoutRandom() {
        _seed = (_seed * 9301 + 49297) % 233280;
        return _seed / 233280;
    }

    function variationRandom() {
        return Math.random();
    }

    let width, height;
    let placedElements = [];

    function initSheet() {
        // High DPI Support
        // Cap DPR at 2 to avoid creating excessively large canvases on super-high-res devices
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        
        // Logical Dimensions (match app base so CSS transform scales everything uniformly)
        width = CONFIG.sheetSize;
        height = CONFIG.sheetSize;
        
        // Set physical size (pixels)
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        
        // Set display size (css) to the logical sheet size (matches #main-container base)
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        
        // Reset any previous transform to avoid cumulative scaling, then scale for DPR
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        
        _seed = CONFIG.layoutSeed;
        drawPattern();
    }

    function getDistance(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function isOverlapping(x, y, radius) {
        for (const element of placedElements) {
            const dist = getDistance(x, y, element.x, element.y);
            if (dist < element.radius + radius + 15) {
                return true;
            }
        }
        return false;
    }

    // --- Drawing Primitives (Preserved from optimized version) ---

    function drawLeaf(x, y, angle, scale) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.scale(scale, scale);
        
        ctx.fillStyle = CONFIG.color;
        
        ctx.beginPath();
        ctx.moveTo(0, 0);
        
        const j1 = (variationRandom() - 0.5) * 2;
        const j2 = (variationRandom() - 0.5) * 2;
        
        ctx.bezierCurveTo(5+j1, -4+j2, 10-j1, -6-j2, 15+j1, -3+j2);
        ctx.bezierCurveTo(18-j1, -5-j2, 22+j1, -4+j2, 25, 0); 
        ctx.bezierCurveTo(22-j1, 4-j2, 18+j1, 5+j2, 15-j1, 3-j2);
        ctx.bezierCurveTo(10+j1, 6+j2, 5-j1, 4-j2, 0, 0);
        ctx.fill();
        
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 0.7;
        ctx.beginPath();
        ctx.moveTo(2, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();

        ctx.restore();
    }

    function drawBud(x, y, angle, scale = 1.0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.scale(scale, scale);

        const ctrlX = 5 + (variationRandom() - 0.5) * 4;
        const ctrlY = -2 + (variationRandom() - 0.5) * 4;

        ctx.beginPath();
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = 0.5;
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(ctrlX, ctrlY, 10, 0);
        ctx.stroke();

        const budTip = 15 + (variationRandom() - 0.5) * 2; 
        const budWidth = 3 + (variationRandom() - 0.5) * 1.5; 
        
        ctx.fillStyle = CONFIG.flowerColor;
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.bezierCurveTo(12, -budWidth, 14, -budWidth, budTip, 0);
        ctx.bezierCurveTo(14, budWidth, 12, budWidth, 10, 0);
        ctx.fill();

        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 0.3;
        ctx.beginPath();
        ctx.moveTo(11, 0); ctx.lineTo(budTip - 1, 0);
        ctx.stroke();

        const numLeaves = 1 + Math.floor(variationRandom() * 2);
        for(let i=0; i<numLeaves; i++) {
            const t = 0.3 + variationRandom() * 0.4; 
            const mt = 1-t;
            const lx = mt*mt*0 + 2*mt*t*ctrlX + t*t*10;
            const ly = mt*mt*0 + 2*mt*t*ctrlY + t*t*0;
            drawLeaf(lx, ly, angle + (variationRandom()>0.5 ? 0.8:-0.8), 0.3);
        }

        ctx.restore();
    }

    function drawRosette(x, y, angle, scale = 1.0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle); 
        ctx.scale(scale, scale);

        const stemLength = 15;
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = CONFIG.lineWidth;
        
        ctx.beginPath();
        ctx.moveTo(-2, 0); 
        ctx.quadraticCurveTo(stemLength/2, (layoutRandom()-0.5)*4, stemLength, 0);
        ctx.stroke();

        ctx.translate(stemLength, 0);

        const cx = (variationRandom() - 0.5) * 1.5;
        const cy = (variationRandom() - 0.5) * 1.5;

        for(let j=-1; j<=1; j++) {
             const fanAngle = j * 0.6; 
             const startDist = 16; 
             const bx = cx + Math.cos(fanAngle) * startDist;
             const by = cy + Math.sin(fanAngle) * startDist;
             
             ctx.beginPath();
             ctx.lineWidth = 0.5;
             ctx.strokeStyle = CONFIG.color;
             ctx.moveTo(cx, cy);
             ctx.quadraticCurveTo(
                 cx + Math.cos(fanAngle) * (startDist/2), 
                 cy + Math.sin(fanAngle) * (startDist/2) + (j===0?0:(j*2)),
                 bx, by
             );
             ctx.stroke();
             drawBud(bx, by, fanAngle, 0.6);
        }

        ctx.fillStyle = CONFIG.detailColor;
        ctx.beginPath();
        ctx.ellipse(cx, cy, 3.5 + (variationRandom()-0.5), 3.5 + (variationRandom()-0.5), variationRandom(), 0, Math.PI*2);
        ctx.fill();

        ctx.strokeStyle = CONFIG.flowerColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        const ringRadius = 6;
        for(let i=0; i<=20; i++) {
            const a = (i/20) * Math.PI*2;
            const r = ringRadius + (variationRandom() - 0.5) * 1.2;
            const px = cx + r * Math.cos(a);
            const py = cy + r * Math.sin(a);
            if(i===0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.stroke();

        // OPTIMIZATION: Calculate all petal properties first to preserve seed order
        const petalCount = 8;
        const petalOffset = Math.PI / 8;
        const petals = [];

        for(let i = 0; i < petalCount; i++) {
            const theta = (i / petalCount) * Math.PI * 2 + petalOffset + (variationRandom() - 0.5) * 0.1;
            const pLen = 7 + (variationRandom() - 0.5) * 2;
            const pWidth = 3.5 + (variationRandom() - 0.5) * 1.5;
            const pRot = (variationRandom()-0.5)*0.2;
            const s1 = (variationRandom() - 0.5);
            const s2 = (variationRandom() - 0.5);
            petals.push({theta, pLen, pWidth, pRot, s1, s2});
        }

        // OPTIMIZATION: Batch draw all petal fills
        ctx.fillStyle = CONFIG.flowerColor;
        ctx.beginPath();
        petals.forEach(p => {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(p.theta);
            ctx.moveTo(11 + p.pLen, 0); // approx move to avoids lines between petals
            ctx.ellipse(11, 0, p.pLen, p.pWidth, p.pRot, 0, Math.PI * 2);
            ctx.restore();
        });
        ctx.fill();

        // OPTIMIZATION: Batch draw all petal details
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        petals.forEach(p => {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(p.theta);
            ctx.moveTo(5+p.s1, 0+p.s2); ctx.lineTo(13-p.s1, 0-p.s2);
            ctx.moveTo(6+p.s2, 1.2+p.s1); ctx.lineTo(11-p.s2, 1.8-p.s1);
            ctx.moveTo(6-p.s1, -1.2-p.s2); ctx.lineTo(11+p.s1, -1.8+p.s2);
            ctx.restore();
        });
        ctx.stroke();

        ctx.restore();
    }

    function drawPalmette(x, y, angle, scale = 1.0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.scale(scale, scale);

        const stemLength = 10; 
        
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = CONFIG.lineWidth;
        ctx.beginPath();
        ctx.moveTo(-2, 0); 
        ctx.quadraticCurveTo(stemLength/2, (layoutRandom()-0.5)*2, stemLength + 1, 0);
        ctx.stroke();

        ctx.translate(stemLength, 0);

        // Base
        ctx.fillStyle = CONFIG.color;
        ctx.beginPath();
        ctx.ellipse(0, 0, 3.5 + (variationRandom()-0.5), 3.5 + (variationRandom()-0.5), variationRandom(), 0, Math.PI*2);
        ctx.fill();

        // OPTIMIZATION: Pre-calculate fan petals
        const fanParts = [];
        for(let i = -2; i <= 2; i++) {
            const theta = i * 0.45 + (variationRandom() - 0.5) * 0.2;
            const jx = (variationRandom() - 0.5) * 3;
            const jy = (variationRandom() - 0.5) * 3;
            fanParts.push({theta, jx, jy});
        }

        // Batch Fills
        ctx.fillStyle = CONFIG.flowerColor;
        ctx.beginPath();
        fanParts.forEach(p => {
            ctx.save();
            ctx.rotate(p.theta);
            ctx.moveTo(0,0);
            ctx.quadraticCurveTo(6+p.jx, -4+p.jy, 16-p.jx, -3-p.jy);
            ctx.quadraticCurveTo(18+p.jx, 0+p.jy, 16-p.jx, 3+p.jy);
            ctx.quadraticCurveTo(6+p.jx, 4-p.jy, 0, 0);
            ctx.restore();
        });
        ctx.fill();

        // Batch Strokes
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        fanParts.forEach(p => {
            ctx.save();
            ctx.rotate(p.theta);
            ctx.moveTo(4,0); ctx.lineTo(14+p.jx,0);
            ctx.restore();
        });
        ctx.stroke();

        ctx.restore();
    }

    function drawBranch(x, y, length, angle, depth) {
        if (depth <= 0) {
            if(layoutRandom() > 0.5) drawRosette(x, y, angle, 0.7);
            else drawPalmette(x, y, angle - Math.PI/2, 0.7);
            return;
        }

        const endX = x + Math.cos(angle) * length;
        const endY = y + Math.sin(angle) * length;

        ctx.beginPath();
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = Math.max(0.3, CONFIG.lineWidth * (depth / 1.5)); 
        
        const ctrlX = (x + endX) / 2 + (layoutRandom() - 0.5) * 20;
        const ctrlY = (y + endY) / 2 + (layoutRandom() - 0.5) * 20;
        
        ctx.quadraticCurveTo(ctrlX, ctrlY, endX, endY);
        ctx.stroke();

        drawBranch(endX, endY, length * 0.7, angle + (layoutRandom() - 0.5) * 1.0, depth - 1);
    }

    function drawDecoratedSide(x1, y1, x2, y2, curvatureDirection, sideIndex) {
        ctx.beginPath();
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = CONFIG.lineWidth;
        
        const dx = x2 - x1;
        const dy = y2 - y1;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const midX = (x1 + x2) / 2;
        // fixed: midY should be average of y1 and y2
        const midY = (y1 + y2) / 2;

        let perpX = -dy / dist;
        let perpY = dx / dist;

        perpX *= curvatureDirection;
        perpY *= curvatureDirection;
        
        const swayAmount = CONFIG.sway;
        const cp1x = midX + perpX * swayAmount;
        const cp1y = midY + perpY * swayAmount;

        ctx.moveTo(x1, y1);
        ctx.quadraticCurveTo(cp1x, cp1y, x2, y2);
        ctx.stroke();

        const numElements = 8; 
        
        for(let i = 0; i < numElements; i++) {
            const segmentSize = 1.0 / numElements;
            const t = (i * segmentSize) + (layoutRandom() * segmentSize * 0.8) + (segmentSize * 0.1);

            const bx = (1-t)*(1-t)*x1 + 2*(1-t)*t*cp1x + t*t*x2;
            const by = (1-t)*(1-t)*y1 + 2*(1-t)*t*cp1y + t*t*y2;

            const tx = 2*(1-t)*(cp1x - x1) + 2*t*(x2 - cp1x);
            const ty = 2*(1-t)*(cp1y - y1) + 2*t*(y2 - cp1y);
            const tangentAngle = Math.atan2(ty, tx);

            const type = layoutRandom();
        
            if (type > 0.55) {
                const scale = 0.9 + layoutRandom() * 0.3;
                const radius = 25 * scale; 
                const flip = layoutRandom() > 0.5 ? 1 : -1; 
                
                if (!isOverlapping(bx, by, radius)) {
                    placedElements.push({x: bx, y: by, radius: radius});
                    drawRosette(bx, by, tangentAngle + (Math.PI/2 * flip), scale);
                }
            } else if (type > 0.25) {
                const scale = 0.8 + layoutRandom() * 0.2;
                const radius = 18 * scale; 
                const flip = layoutRandom() > 0.5 ? 1 : -1;
                
                if (!isOverlapping(bx, by, radius)) {
                    placedElements.push({x: bx, y: by, radius: radius});
                    drawPalmette(bx, by, tangentAngle - (Math.PI/2 * flip), scale);
                }
            } else {
                drawBranch(bx, by, 30, tangentAngle + (layoutRandom() > 0.5 ? 1.2 : -1.2), 1);
            }
        }
    }

    function drawPattern() {
        placedElements = [];

        // Note: Canvas clears automatically when redrawn or initialized usually, 
        // but explicit clear is good practice if resizing/redrawing often
        ctx.fillStyle = '#ffffff'; 
        ctx.fillRect(0, 0, width, height);

        ctx.strokeStyle = '#f8f9fa';
        ctx.lineWidth = 1.2;
        for(let x = 0; x < width; x += 14) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke();
        }

        // Draw Pattern centered in the massive sheet
        const cx = width / 2; 
        const cy = height / 2;
        const size = CONFIG.squareSize;

        const corners = [
            { x: cx - size/2, y: cy - size/2 }, // Top Left
            { x: cx + size/2, y: cy - size/2 }, // Top Right
            { x: cx + size/2, y: cy + size/2 }, // Bottom Right
            { x: cx - size/2, y: cy + size/2 }  // Bottom Left
        ];
        
        corners.forEach((corner, index) => {
            const cornerAngle = (index * Math.PI/2) - 3*Math.PI/4;
            const scale = 0.9;
            placedElements.push({x: corner.x, y: corner.y, radius: 28 * scale});
            drawRosette(corner.x, corner.y, cornerAngle, scale);
        });

        drawDecoratedSide(corners[0].x, corners[0].y, corners[1].x, corners[1].y, -1); 
        drawDecoratedSide(corners[1].x, corners[1].y, corners[2].x, corners[2].y, -1); 
        drawDecoratedSide(corners[2].x, corners[2].y, corners[3].x, corners[3].y, -1); 
        drawDecoratedSide(corners[3].x, corners[3].y, corners[0].x, corners[0].y, -1); 
    }

    // Start
    requestAnimationFrame(initSheet);

    // Polyfill for ctx.ellipse in older Safari
    if (typeof CanvasRenderingContext2D !== 'undefined' && !CanvasRenderingContext2D.prototype.ellipse) {
        CanvasRenderingContext2D.prototype.ellipse = function(cx, cy, rx, ry, rotation, startAngle, endAngle, anticlockwise) {
            // save/translate/scale approach
            this.save();
            this.translate(cx, cy);
            this.rotate(rotation || 0);
            this.scale(rx, ry);
            this.beginPath();
            // draw unit circle arc then restore
            this.arc(0, 0, 1, startAngle, endAngle, anticlockwise || false);
            this.restore();
        };
    }

</script>
</body>
</html>