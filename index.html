<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anne's Birthday Bingo</title>
    <!-- Import a font that matches the Royal Copenhagen vibe -->
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    
</head>
<body>

<!-- Welcome Banner -->
<div id="welcomeBanner" class="welcome-banner">
    <h2>Welcome to Anne’s Birthday Pub Crawl!</h2>
    <p>Get ready for the 12 Pubs of Christmas and Pub Bingo. Check the route, follow the rules, and let’s party!</p>
    <button onclick="dismissWelcome()">Let the Games Begin</button>
</div>

<!-- Unified Container for Scaling -->
<main id="main-container">
    
    <!-- Background Pattern -->
    <canvas id="patternCanvas"></canvas>

    <!-- Headers -->
    <header class="header-group">
        <h1>Anne's Birthday</h1>
        <div class="tabs" role="tablist">
            <button class="tab-btn active" data-tab="pubs" role="tab" aria-selected="true" aria-controls="pubsContent">12 Pubs of Christmas</button> 
            <button class="tab-btn" data-tab="bingo" role="tab" aria-selected="false" aria-controls="bingoContent">Pub Crawl Bingo</button>
        </div>
    </header>
    
    <!-- Tabbed Content: Bingo (default) -->
    <div id="bingoContent" class="tab-content" role="tabpanel" aria-labelledby="tab-bingo">
        <!-- Grid -->
        <div class="bingo-grid" id="grid"></div>

        <!-- Controls -->
        <div class="controls">
            <button class="reset-btn" id="reset-btn">Reset Board</button>
        </div>
    </div>

    <!-- Tabbed Content: 12 Pubs of Christmas -->
    <div id="pubsContent" class="tab-content hidden" role="tabpanel" aria-labelledby="tab-pubs">
        <!-- centered-content is counter-scaled so it keeps centered position regardless of zoom -->
        <div class="centered-content counter-scale">
            <div class="pubs-panel" id="pubsPanel">
                <h2 class="pubs-title">12 Pubs of Christmas — Nick Miller edition</h2>
                <p><strong>Overall rule:</strong> Respect the crawl. Any disrespect and you drink. When someone says '29' (<a class="map-link" href="https://youtu.be/vCFs64HBvSY?t=10" target="_blank" rel="noopener noreferrer">The Schmidt way</a>), everyone must drink.</p>
                <p><strong>START:</strong> 3.30pm</p>

                <ol id="pubsList">
                    <li><strong>Pub 1:</strong> <a class="map-link" href="https://www.google.com/maps/search/?api=1&query=67A%20Tabley%20Road" target="_blank" rel="noopener noreferrer">67A Tabley Road</a>: Abs becomes the Oracle and must make predictions about the rest of the night. If anyone challenges the Oracle, they must take a sip.</li>
                    <li><strong>Pub 2:</strong> <a class="map-link" href="https://www.google.com/maps/search/?api=1&query=The%20Prince%20Edward%2038%20Parkhurst%20Rd%20London%20N7%200SF" target="_blank" rel="noopener noreferrer">The Prince Edward — 38 Parkhurst Rd, London N7 0SF</a> — <em>Nick Miller cheapskate rule</em>: Everyone must buy the cheapest drink on the menu. If you fail to do so, or try to upgrade, you have to tell the group a secret you’ve never shared before.</li>
                    <li><strong>Pub 3:</strong> <a class="map-link" href="https://www.google.com/maps/search/?api=1&query=The%20Crown%20622%20Holloway%20Rd%20Archway%20London%20N19%203PA" target="_blank" rel="noopener noreferrer">The Crown — 622 Holloway Rd, Archway, London N19 3PA</a> — <em>The crawl doesn’t wait rule</em>: Once one person finishes their drink, we must move to the next pub within 2 minutes.</li>
                    <li><strong>Pub 4:</strong> <a class="map-link" href="https://www.google.com/maps/search/?api=1&query=The%20Landseer%20Arms%2037%20Landseer%20Rd%20London%20N19%204JU" target="_blank" rel="noopener noreferrer">The Landseer Arms — 37 Landseer Rd, London N19 4JU</a> — <em>The Schmidt sentimental rule</em>: Before your first sip, everyone must say one sincere, borderline dramatic compliment about me. If it’s too vague, you have to finish your drink.</li>
                    <li><strong>Pub 5:</strong> <a class="map-link" href="https://www.google.com/maps/search/?api=1&query=The%20Swimmer%20at%20the%20Grafton%20Arms%2013%20Eburne%20Rd%20London%20N7%206AR" target="_blank" rel="noopener noreferrer">The Swimmer at the Grafton Arms — 13 Eburne Rd, London N7 6AR</a> — <em>The guide rule</em>: Diana must lead the group with blind confidence and 0 navigation skills to this pub. If we get lost, everyone drinks.</li>
                    <li><strong>BUS BREAK</strong> aka <em>BUZZBALL BREAK</em></li>
                    <li><strong>Pub 6:</strong> <a class="map-link" href="https://www.google.com/maps/search/?api=1&query=The%20Red%20Lion%20132%20Stoke%20Newington%20Church%20St%20London%20N16%200JX" target="_blank" rel="noopener noreferrer">The Red Lion — 132 Stoke Newington Church St, London N16 0JX</a> — <em>The crawl demands a sacrifice rule</em>: Each person must give up one thing for the pub i.e. no drinking with your dominant hand, no straw, no smiling. If you break your rule, you have to take a sip.</li>
                    <li><strong>Pub 7:</strong> <a class="map-link" href="https://www.google.com/maps/search/?api=1&query=The%20Auld%20Shillelagh%20105%20Stoke%20Newington%20Church%20St%20London%20N16%200UD" target="_blank" rel="noopener noreferrer">The Auld Shillelagh — 105 Stoke Newington Church St, London N16 0UD</a> — <em>The Cece and Jess rage rule</em>: Only drinks over 20% allowed and you must say one mildly unhinged sentence about an ex, situationship or work injustice.</li>
                    <li><strong>Pub 8:</strong> <a class="map-link" href="https://www.google.com/maps/search/?api=1&query=Three%20Crowns%20175%20Stoke%20Newington%20High%20St%20London%20N16%200LH" target="_blank" rel="noopener noreferrer">Three Crowns — 175 Stoke Newington High St, London N16 0LH</a> — <em>The Nick Miller spiral rule</em>: Everyone must share a wildly disproportionate worry, and it has to be over something tiny. If it’s actually reasonable, you must drink.</li>
                    <li><strong>Pub 9:</strong> <a class="map-link" href="https://www.google.com/maps/search/?api=1&query=The%20Coach%20%26%20Horses%20178%20Stoke%20Newington%20High%20St%20London%20N16%207JL" target="_blank" rel="noopener noreferrer">The Coach & Horses — 178 Stoke Newington High St, London N16 7JL</a> — <em>The Schmidt confidence rule</em>: Everyone must refer to themselves in the 3rd person.</li>
                    <li><strong>Pub 10:</strong> <a class="map-link" href="https://www.google.com/maps/search/?api=1&query=The%20Rochester%20Castle%20143-145%20Stoke%20Newington%20High%20St%20London%20N16%200NY" target="_blank" rel="noopener noreferrer">The Rochester Castle — 143-145 Stoke Newington High St, London N16 0NY</a> — <em>The Nick Miller zombie novel rule</em>: Everyone must share a personal dream they once abandoned.</li>
                    <li><strong>Pub 11:</strong> <a class="map-link" href="https://www.google.com/maps/search/?api=1&query=The%20White%20Hart%2069%20Stoke%20Newington%20High%20St%20London%20N16%208EL" target="_blank" rel="noopener noreferrer">The White Hart — 69 Stoke Newington High St, London N16 8EL</a> — <em>The Tilly is Winston rule</em>: She must declare a completely pointless, overly intense challenge for the pub. Everyone has to commit; if you refuse or break the rule, you have to finish your drink.</li>
                    <li><strong>Pub 12:</strong> <a class="map-link" href="https://www.google.com/maps/search/?api=1&query=Yucatan%20Bar%20121%20Stoke%20Newington%20Rd%20London%20N16%208BT" target="_blank" rel="noopener noreferrer">Yucatan Bar — 121 Stoke Newington Rd, London N16 8BT</a> — <em>The respect the crawl finale rule</em>: Everyone...</li>
                    <li><strong>Route:</strong> <a class="map-link" href="https://www.google.com/maps/dir/67+Tabley+Rd,+London+N7+0NB/Prince+Edward/The+Crown/The+Landseer+Arms/The+Swimmer+at+the+Grafton+Arms/The+Red+Lion/The+Auld+Shillelagh/Three+Crowns,+Stoke+Newington/The+Coach+%26+Horses/The+Rochester+Castle/The+White+Hart/Yucatan+Bar/@51.5598672,-0.1404484,13065m/data=!3m3!1e3!4b1!5s0x48761c8a6b008bef:0x5db2bf26b0bda968!4m74!4m73!1m5!1m1!1s0x48761b09e0325b25:0x194cc5e162813a58!2m2!1d-0.1248113!2d51.5569584!1m5!1m1!1s0x48761b0bcd79e27f:0xf7251c559972c5ab!2m2!1d-0.1217365!2d51.5554361!1m5!1m1!1s0x48761ba6a3d759bd:0x485bed22a058b0a3!2m2!1d-0.1247478!2d51.5619439!1m5!1m1!1s0x48761ba3e5698c17:0x121629231f93c248!2m2!1d-0.1227414!2d51.5628722!1m5!1m1!1s0x48761ba04b503135:0xab5a3af3e5a5950!2m2!1d-0.119548!2d51.5595696!1m5!1m1!1s0x48761c636113a093:0x15dbc3acd13712c6!2m2!1d-0.080529!2d51.5621101!1m5!1m1!1s0x48761c637f39c6df:0xa9848c15a5121018!2m2!1d-0.0794564!2d51.5620538!1m5!1m1!1s0x48761c612bea7cd9:0xb5f9898753b9de90!2m2!1d-0.0738779!2d51.5620837!1m5!1m1!1s0x48761c6129b85a6b:0x9837c4e8bc7df840!2m2!1d-0.0735034!2d51.5617247!1m5!1m1!1s0x48761c6122793cef:0x4b89ddbd0c9e3f61!2m2!1d-0.0739857!2d51.5609719!1m5!1m1!1s0x48761c61a4e79645:0xce1209d6433b653b!2m2!1d-0.074473!2d51.5591407!1m5!1m1!1s0x48761c8a6ceb017f:0x6bd6dc0603970f02!2m2!1d-0.074865!2d51.5559043!3e2?entry=ttu&g_ep=EgoyMDI1MTIwOC4wIKXMDSoKLDEwMDc5MjA3M0gBUAM%3D" target="_blank" rel="noopener noreferrer">Open full route (start to finish)</a></li>
                </ol>

                
            </div>
        </div>
    </div>

</main>

<script>
    /* -----------------------------------------------------------
       WELCOME BANNER
       ----------------------------------------------------------- */
    function dismissWelcome() {
        const banner = document.getElementById('welcomeBanner');
        const mainContainer = document.getElementById('main-container');
        const headerGroup = document.querySelector('.header-group');
        if (banner) {
            banner.classList.add('hidden');
        }
        if (mainContainer) {
            mainContainer.classList.remove('banner-active');
        }
        if (headerGroup) {
            headerGroup.classList.remove('banner-active');
        }
    }

    // Add blur effect on page load when banner is shown
    window.addEventListener('load', () => {
        const mainContainer = document.getElementById('main-container');
        const headerGroup = document.querySelector('.header-group');
        if (mainContainer) {
            mainContainer.classList.add('banner-active');
        }
        if (headerGroup) {
            headerGroup.classList.add('banner-active');
        }
    });

    /* -----------------------------------------------------------
       SCALING LOGIC
       ----------------------------------------------------------- */
    const container = document.getElementById('main-container');
    const counterElements = document.querySelectorAll('.counter-scale');
    
    function resizeApp() {
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const targetWidth = 800; // Our base design width
        const targetHeight = 800; // Our base design height

        // Determine scale to fit within viewport with some padding
        const scaleX = (windowWidth - 20) / targetWidth;
        const scaleY = (windowHeight - 20) / targetHeight;
        const scale = Math.min(scaleX, scaleY); // Fit to smallest dimension

        // set both standard and webkit transform for Safari compatibility
        const scaleStr = `scale(${scale})`;
        container.style.transform = scaleStr;
        container.style.webkitTransform = scaleStr;

        // Apply inverse scale to elements that should remain readable/constant width
        const inv = isFinite(scale) && scale > 0 ? (1 / scale) : 1;
        // NodeList may not support forEach in older Safari; use a simple loop
        for (let i = 0; i < counterElements.length; i++) {
            const el = counterElements[i];
            const t = `translate(-50%, -50%) scale(${inv})`;
            el.style.transform = t;
            el.style.webkitTransform = t;
        }
    }

    window.addEventListener('resize', resizeApp);
    resizeApp(); // Trigger immediately
    // ensure inverse scale also applied after initial layout (fonts may change)
    window.addEventListener('load', resizeApp);

    // Tab switching for additional pages
    function showTab(name) {
        const tabs = document.querySelectorAll('[role="tab"]');
        tabs.forEach(btn => {
            const isActive = btn.dataset.tab === name;
            btn.classList.toggle('active', isActive);
            btn.setAttribute('aria-selected', isActive);
        });

        const bingoEl = document.getElementById('bingoContent');
        const pubsEl = document.getElementById('pubsContent');

        if (name === 'bingo') {
            if (bingoEl) bingoEl.classList.remove('hidden');
            if (pubsEl) pubsEl.classList.add('hidden');
        } else if (name === 'pubs') {
            if (pubsEl) pubsEl.classList.remove('hidden');
            if (bingoEl) bingoEl.classList.add('hidden');
        }
    }

    // Attach tab click listeners
    document.querySelectorAll('[role="tab"]').forEach(btn => {
        btn.addEventListener('click', () => showTab(btn.dataset.tab));
    });

    // Attach reset button listener
    const resetBtn = document.getElementById('reset-btn');
    if (resetBtn) {
        resetBtn.addEventListener('click', resetBingo);
    }


    /* -----------------------------------------------------------
       BINGO LOGIC
       ----------------------------------------------------------- */
    
    const BINGO_TASKS = [
        "Take a shot with Anne", "Spot a cute Dog", "Drink Water!", "ID Check", "Spill a Drink", "Group Selfie", "Toilet Selfie",
        "Eat a Fry", "Hear 'I love this song!'", "Stranger says HBD", "Lose the Group", "Find the Group", "Text an Ex", "Karaoke Moment",
        "Bartender's Choice", "Drink a Stout", "Drink a Lager", "Drink a Cider", "Drink a Cocktail", "Buy Anne a Drink", "Compliment Stranger",
        "Toast Speech", "Glass Break Sound", "Happy Tears", "Piggyback Ride", "Propose a Toast", "High Five Bouncer", "Irish Exit Spotted",
        "Wrong Pub Entered", "Walk in Rain", "One more drink...", "Order Pizza", "Shoe Untied", "Phone Dies", "Borrow Charger",
        "Spot a Mullet", "Wear a Hat", "Someone Trips", "Get a Free Drink", "Jagerbomb!", "Baby Guinness", "Tequila!",
        "Dance Off", "Request a Song", "Hug Anne", "Anne Laughs", "Photo with Anne", "Pet a Pub Dog", "Survive the Night"
    ];

    const STORAGE_KEY = 'anne_bingo_state_v2';

    function loadState() {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
            return JSON.parse(saved);
        }
        return new Array(49).fill(false);
    }

    function saveState(state) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }

    function initGrid() {
        const gridEl = document.getElementById('grid');
        gridEl.innerHTML = '';

        BINGO_TASKS.forEach((task, index) => {
            const cell = document.createElement('div');
            cell.className = 'bingo-cell';
            cell.id = `cell-${index}`;
            
            // Generate Organic Shape
            const r1 = 200 + Math.random() * 55;
            const r2 = 10 + Math.random() * 30;
            const r3 = 200 + Math.random() * 55;
            const r4 = 10 + Math.random() * 30;
            cell.style.borderRadius = `${r1}px ${r2}px ${r3}px ${r4}px / ${r4}px ${r3}px ${r2}px ${r1}px`;

            cell.innerText = task;

            if (index === 24) { 
                cell.classList.add('center-cell');
            }

            cell.onclick = () => toggleCell(index);
            gridEl.appendChild(cell);
        });

        updateGridUI();
    }

    function updateGridUI() {
        const state = loadState();
        BINGO_TASKS.forEach((_, index) => {
            const cell = document.getElementById(`cell-${index}`);
            if (state[index]) {
                cell.classList.add('checked');
            } else {
                cell.classList.remove('checked');
            }
        });
    }

    function toggleCell(index) {
        const state = loadState();
        state[index] = !state[index];
        saveState(state);
        updateGridUI();
    }

    function resetBingo() {
        if(confirm("Are you sure you want to clear the board and reset progress?")) {
            // Clear specific key
            localStorage.removeItem(STORAGE_KEY);
            // OR clear all if requested: localStorage.clear();
            
            updateGridUI(); // Will revert to default false state
        }
    }

    initGrid();
    // Ensure the default tab is visible on load
    if (typeof showTab === 'function') showTab('pubs');

    /* -----------------------------------------------------------
       PUBS CHECKBOXES + PERSISTENCE
       ----------------------------------------------------------- */
    const PUBS_STORAGE_KEY = 'anne_pubs_state_v1';

    function loadPubsState(count) {
        const saved = localStorage.getItem(PUBS_STORAGE_KEY);
        if (saved) {
            try { const parsed = JSON.parse(saved); if (Array.isArray(parsed)) return parsed; } catch(e){}
        }
        return new Array(count).fill(false);
    }

    function savePubsState(state) {
        localStorage.setItem(PUBS_STORAGE_KEY, JSON.stringify(state));
    }

    function initPubsCheckboxes() {
        const ol = document.getElementById('pubsList');
        if (!ol) return;
        const items = Array.from(ol.querySelectorAll('li'));
        const state = loadPubsState(items.length);

        items.forEach((li, idx) => {
            // wrap content in flex row and append checkbox
            const text = document.createElement('div');
            text.className = 'pub-label';
            // keep the existing innerHTML as label
            text.innerHTML = li.innerHTML;

            const checkbox = document.createElement('button');
            checkbox.type = 'button';
            checkbox.className = 'pub-checkbox';
            checkbox.setAttribute('aria-pressed', state[idx] ? 'true' : 'false');
            checkbox.dataset.index = idx;

            if (state[idx]) checkbox.classList.add('checked');

            checkbox.onclick = () => {
                const s = loadPubsState(items.length);
                s[idx] = !s[idx];
                savePubsState(s);
                checkbox.classList.toggle('checked', s[idx]);
                checkbox.setAttribute('aria-pressed', s[idx] ? 'true' : 'false');
            };

            // replace li content with structured row
            li.innerHTML = '';
            li.classList.add('pub-row');
            li.appendChild(text);
            li.appendChild(checkbox);
        });
    }

    // Initialize pubs checkboxes once DOM is ready
    document.addEventListener('DOMContentLoaded', initPubsCheckboxes);
    // In case script runs after DOMContentLoaded
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        initPubsCheckboxes();
    }
 
    /* -----------------------------------------------------------
       BACKGROUND PATTERN GENERATOR
       ----------------------------------------------------------- */

    const canvas = document.getElementById('patternCanvas');
    const ctx = canvas.getContext('2d');

    // Configuration
    const CONFIG = {
        color: '#1a45a0', 
        detailColor: '#123275',
        flowerColor: '#2b5bbd', 
        lineWidth: 0.6, 
        // Align sheet to the app base resolution so the canvas visuals scale exactly with the container
        sheetSize: 1000,
        squareSize: 600, 
        sway: 60,
        layoutSeed: 111,
        skippedElements: []
    };

    let _seed = CONFIG.layoutSeed;
    function layoutRandom() {
        _seed = (_seed * 9301 + 49297) % 233280;
        return _seed / 233280;
    }

    function variationRandom() {
        return Math.random();
    }

    let width, height;
    let placedElements = [];

    function initSheet() {
        // High DPI Support
        // Cap DPR at 2 to avoid creating excessively large canvases on super-high-res devices
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        
        // Logical Dimensions (match app base so CSS transform scales everything uniformly)
        width = CONFIG.sheetSize;
        height = CONFIG.sheetSize;
        
        // Set physical size (pixels)
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        
        // Set display size (css) to the logical sheet size (matches #main-container base)
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        
        // Reset any previous transform to avoid cumulative scaling, then scale for DPR
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        
        _seed = CONFIG.layoutSeed;
        drawPattern();
    }

    function getDistance(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function isOverlapping(x, y, radius) {
        for (const element of placedElements) {
            const dist = getDistance(x, y, element.x, element.y);
            if (dist < element.radius + radius + 15) {
                return true;
            }
        }
        return false;
    }

    // --- Drawing Primitives (Preserved from optimized version) ---

    function drawLeaf(x, y, angle, scale) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.scale(scale, scale);
        
        ctx.fillStyle = CONFIG.color;
        
        ctx.beginPath();
        ctx.moveTo(0, 0);
        
        const j1 = (variationRandom() - 0.5) * 2;
        const j2 = (variationRandom() - 0.5) * 2;
        
        ctx.bezierCurveTo(5+j1, -4+j2, 10-j1, -6-j2, 15+j1, -3+j2);
        ctx.bezierCurveTo(18-j1, -5-j2, 22+j1, -4+j2, 25, 0); 
        ctx.bezierCurveTo(22-j1, 4-j2, 18+j1, 5+j2, 15-j1, 3-j2);
        ctx.bezierCurveTo(10+j1, 6+j2, 5-j1, 4-j2, 0, 0);
        ctx.fill();
        
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 0.7;
        ctx.beginPath();
        ctx.moveTo(2, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();

        ctx.restore();
    }

    function drawBud(x, y, angle, scale = 1.0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.scale(scale, scale);

        const ctrlX = 5 + (variationRandom() - 0.5) * 4;
        const ctrlY = -2 + (variationRandom() - 0.5) * 4;

        ctx.beginPath();
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = 0.5;
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(ctrlX, ctrlY, 10, 0);
        ctx.stroke();

        const budTip = 15 + (variationRandom() - 0.5) * 2; 
        const budWidth = 3 + (variationRandom() - 0.5) * 1.5; 
        
        ctx.fillStyle = CONFIG.flowerColor;
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.bezierCurveTo(12, -budWidth, 14, -budWidth, budTip, 0);
        ctx.bezierCurveTo(14, budWidth, 12, budWidth, 10, 0);
        ctx.fill();

        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 0.3;
        ctx.beginPath();
        ctx.moveTo(11, 0); ctx.lineTo(budTip - 1, 0);
        ctx.stroke();

        const numLeaves = 1 + Math.floor(variationRandom() * 2);
        for(let i=0; i<numLeaves; i++) {
            const t = 0.3 + variationRandom() * 0.4; 
            const mt = 1-t;
            const lx = mt*mt*0 + 2*mt*t*ctrlX + t*t*10;
            const ly = mt*mt*0 + 2*mt*t*ctrlY + t*t*0;
            drawLeaf(lx, ly, angle + (variationRandom()>0.5 ? 0.8:-0.8), 0.3);
        }

        ctx.restore();
    }

    function drawRosette(x, y, angle, scale = 1.0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle); 
        ctx.scale(scale, scale);

        const stemLength = 15;
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = CONFIG.lineWidth;
        
        ctx.beginPath();
        ctx.moveTo(-2, 0); 
        ctx.quadraticCurveTo(stemLength/2, (layoutRandom()-0.5)*4, stemLength, 0);
        ctx.stroke();

        ctx.translate(stemLength, 0);

        const cx = (variationRandom() - 0.5) * 1.5;
        const cy = (variationRandom() - 0.5) * 1.5;

        for(let j=-1; j<=1; j++) {
             const fanAngle = j * 0.6; 
             const startDist = 16; 
             const bx = cx + Math.cos(fanAngle) * startDist;
             const by = cy + Math.sin(fanAngle) * startDist;
             
             ctx.beginPath();
             ctx.lineWidth = 0.5;
             ctx.strokeStyle = CONFIG.color;
             ctx.moveTo(cx, cy);
             ctx.quadraticCurveTo(
                 cx + Math.cos(fanAngle) * (startDist/2), 
                 cy + Math.sin(fanAngle) * (startDist/2) + (j===0?0:(j*2)),
                 bx, by
             );
             ctx.stroke();
             drawBud(bx, by, fanAngle, 0.6);
        }

        ctx.fillStyle = CONFIG.detailColor;
        ctx.beginPath();
        ctx.ellipse(cx, cy, 3.5 + (variationRandom()-0.5), 3.5 + (variationRandom()-0.5), variationRandom(), 0, Math.PI*2);
        ctx.fill();

        ctx.strokeStyle = CONFIG.flowerColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        const ringRadius = 6;
        for(let i=0; i<=20; i++) {
            const a = (i/20) * Math.PI*2;
            const r = ringRadius + (variationRandom() - 0.5) * 1.2;
            const px = cx + r * Math.cos(a);
            const py = cy + r * Math.sin(a);
            if(i===0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.stroke();

        // OPTIMIZATION: Calculate all petal properties first to preserve seed order
        const petalCount = 8;
        const petalOffset = Math.PI / 8;
        const petals = [];

        for(let i = 0; i < petalCount; i++) {
            const theta = (i / petalCount) * Math.PI * 2 + petalOffset + (variationRandom() - 0.5) * 0.1;
            const pLen = 7 + (variationRandom() - 0.5) * 2;
            const pWidth = 3.5 + (variationRandom() - 0.5) * 1.5;
            const pRot = (variationRandom()-0.5)*0.2;
            const s1 = (variationRandom() - 0.5);
            const s2 = (variationRandom() - 0.5);
            petals.push({theta, pLen, pWidth, pRot, s1, s2});
        }

        // OPTIMIZATION: Batch draw all petal fills
        ctx.fillStyle = CONFIG.flowerColor;
        ctx.beginPath();
        petals.forEach(p => {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(p.theta);
            ctx.moveTo(11 + p.pLen, 0); // approx move to avoids lines between petals
            ctx.ellipse(11, 0, p.pLen, p.pWidth, p.pRot, 0, Math.PI * 2);
            ctx.restore();
        });
        ctx.fill();

        // OPTIMIZATION: Batch draw all petal details
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        petals.forEach(p => {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(p.theta);
            ctx.moveTo(5+p.s1, 0+p.s2); ctx.lineTo(13-p.s1, 0-p.s2);
            ctx.moveTo(6+p.s2, 1.2+p.s1); ctx.lineTo(11-p.s2, 1.8-p.s1);
            ctx.moveTo(6-p.s1, -1.2-p.s2); ctx.lineTo(11+p.s1, -1.8+p.s2);
            ctx.restore();
        });
        ctx.stroke();

        ctx.restore();
    }

    function drawPalmette(x, y, angle, scale = 1.0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.scale(scale, scale);

        const stemLength = 10; 
        
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = CONFIG.lineWidth;
        ctx.beginPath();
        ctx.moveTo(-2, 0); 
        ctx.quadraticCurveTo(stemLength/2, (layoutRandom()-0.5)*2, stemLength + 1, 0);
        ctx.stroke();

        ctx.translate(stemLength, 0);

        // Base
        ctx.fillStyle = CONFIG.color;
        ctx.beginPath();
        ctx.ellipse(0, 0, 3.5 + (variationRandom()-0.5), 3.5 + (variationRandom()-0.5), variationRandom(), 0, Math.PI*2);
        ctx.fill();

        // OPTIMIZATION: Pre-calculate fan petals
        const fanParts = [];
        for(let i = -2; i <= 2; i++) {
            const theta = i * 0.45 + (variationRandom() - 0.5) * 0.2;
            const jx = (variationRandom() - 0.5) * 3;
            const jy = (variationRandom() - 0.5) * 3;
            fanParts.push({theta, jx, jy});
        }

        // Batch Fills
        ctx.fillStyle = CONFIG.flowerColor;
        ctx.beginPath();
        fanParts.forEach(p => {
            ctx.save();
            ctx.rotate(p.theta);
            ctx.moveTo(0,0);
            ctx.quadraticCurveTo(6+p.jx, -4+p.jy, 16-p.jx, -3-p.jy);
            ctx.quadraticCurveTo(18+p.jx, 0+p.jy, 16-p.jx, 3+p.jy);
            ctx.quadraticCurveTo(6+p.jx, 4-p.jy, 0, 0);
            ctx.restore();
        });
        ctx.fill();

        // Batch Strokes
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        fanParts.forEach(p => {
            ctx.save();
            ctx.rotate(p.theta);
            ctx.moveTo(4,0); ctx.lineTo(14+p.jx,0);
            ctx.restore();
        });
        ctx.stroke();

        ctx.restore();
    }

    function drawBranch(x, y, length, angle, depth) {
        if (depth <= 0) {
            if(layoutRandom() > 0.5) drawRosette(x, y, angle, 0.7);
            else drawPalmette(x, y, angle - Math.PI/2, 0.7);
            return;
        }

        const endX = x + Math.cos(angle) * length;
        const endY = y + Math.sin(angle) * length;

        ctx.beginPath();
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = Math.max(0.3, CONFIG.lineWidth * (depth / 1.5)); 
        
        const ctrlX = (x + endX) / 2 + (layoutRandom() - 0.5) * 20;
        const ctrlY = (y + endY) / 2 + (layoutRandom() - 0.5) * 20;
        
        ctx.quadraticCurveTo(ctrlX, ctrlY, endX, endY);
        ctx.stroke();

        drawBranch(endX, endY, length * 0.7, angle + (layoutRandom() - 0.5) * 1.0, depth - 1);
    }

    function drawDecoratedSide(x1, y1, x2, y2, curvatureDirection, sideIndex) {
        ctx.beginPath();
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = CONFIG.lineWidth;
        
        const dx = x2 - x1;
        const dy = y2 - y1;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const midX = (x1 + x2) / 2;
        // fixed: midY should be average of y1 and y2
        const midY = (y1 + y2) / 2;

        let perpX = -dy / dist;
        let perpY = dx / dist;

        perpX *= curvatureDirection;
        perpY *= curvatureDirection;
        
        const swayAmount = CONFIG.sway;
        const cp1x = midX + perpX * swayAmount;
        const cp1y = midY + perpY * swayAmount;

        ctx.moveTo(x1, y1);
        ctx.quadraticCurveTo(cp1x, cp1y, x2, y2);
        ctx.stroke();

        const numElements = 8; 
        
        for(let i = 0; i < numElements; i++) {
            const segmentSize = 1.0 / numElements;
            const t = (i * segmentSize) + (layoutRandom() * segmentSize * 0.8) + (segmentSize * 0.1);

            const bx = (1-t)*(1-t)*x1 + 2*(1-t)*t*cp1x + t*t*x2;
            const by = (1-t)*(1-t)*y1 + 2*(1-t)*t*cp1y + t*t*y2;

            const tx = 2*(1-t)*(cp1x - x1) + 2*t*(x2 - cp1x);
            const ty = 2*(1-t)*(cp1y - y1) + 2*t*(y2 - cp1y);
            const tangentAngle = Math.atan2(ty, tx);

            const type = layoutRandom();
        
            if (type > 0.55) {
                const scale = 0.9 + layoutRandom() * 0.3;
                const radius = 25 * scale; 
                const flip = layoutRandom() > 0.5 ? 1 : -1; 
                
                if (!isOverlapping(bx, by, radius)) {
                    placedElements.push({x: bx, y: by, radius: radius});
                    drawRosette(bx, by, tangentAngle + (Math.PI/2 * flip), scale);
                }
            } else if (type > 0.25) {
                const scale = 0.8 + layoutRandom() * 0.2;
                const radius = 18 * scale; 
                const flip = layoutRandom() > 0.5 ? 1 : -1;
                
                if (!isOverlapping(bx, by, radius)) {
                    placedElements.push({x: bx, y: by, radius: radius});
                    drawPalmette(bx, by, tangentAngle - (Math.PI/2 * flip), scale);
                }
            } else {
                drawBranch(bx, by, 30, tangentAngle + (layoutRandom() > 0.5 ? 1.2 : -1.2), 1);
            }
        }
    }

    function drawPattern() {
        placedElements = [];

        // Note: Canvas clears automatically when redrawn or initialized usually, 
        // but explicit clear is good practice if resizing/redrawing often
        ctx.fillStyle = '#ffffff'; 
        ctx.fillRect(0, 0, width, height);

        ctx.strokeStyle = '#f8f9fa';
        ctx.lineWidth = 1.2;
        for(let x = 0; x < width; x += 14) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke();
        }

        // Draw Pattern centered in the massive sheet
        const cx = width / 2; 
        const cy = height / 2;
        const size = CONFIG.squareSize;

        const corners = [
            { x: cx - size/2, y: cy - size/2 }, // Top Left
            { x: cx + size/2, y: cy - size/2 }, // Top Right
            { x: cx + size/2, y: cy + size/2 }, // Bottom Right
            { x: cx - size/2, y: cy + size/2 }  // Bottom Left
        ];
        
        corners.forEach((corner, index) => {
            const cornerAngle = (index * Math.PI/2) - 3*Math.PI/4;
            const scale = 0.9;
            placedElements.push({x: corner.x, y: corner.y, radius: 28 * scale});
            drawRosette(corner.x, corner.y, cornerAngle, scale);
        });

        drawDecoratedSide(corners[0].x, corners[0].y, corners[1].x, corners[1].y, -1); 
        drawDecoratedSide(corners[1].x, corners[1].y, corners[2].x, corners[2].y, -1); 
        drawDecoratedSide(corners[2].x, corners[2].y, corners[3].x, corners[3].y, -1); 
        drawDecoratedSide(corners[3].x, corners[3].y, corners[0].x, corners[0].y, -1); 
    }

    // Start
    requestAnimationFrame(initSheet);

    // Polyfill for ctx.ellipse in older Safari
    if (typeof CanvasRenderingContext2D !== 'undefined' && !CanvasRenderingContext2D.prototype.ellipse) {
        CanvasRenderingContext2D.prototype.ellipse = function(cx, cy, rx, ry, rotation, startAngle, endAngle, anticlockwise) {
            // save/translate/scale approach
            this.save();
            this.translate(cx, cy);
            this.rotate(rotation || 0);
            this.scale(rx, ry);
            this.beginPath();
            // draw unit circle arc then restore
            this.arc(0, 0, 1, startAngle, endAngle, anticlockwise || false);
            this.restore();
        };
    }

</script>
</body>
</html>