<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anne's Birthday Bingo</title>
    <!-- Import a font that matches the Royal Copenhagen vibe -->
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #ffffff; /* Fallback */
            font-family: 'Playfair Display', serif;
            overflow: hidden; /* Prevent scrolling to keep the "app" feel */
        }

        /* --- BACKGROUND CANVAS --- */
        canvas {
            display: block;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 0; /* Background layer */
            pointer-events: none; 
        }

        /* --- BINGO UI CONTAINER --- */
        #app {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none; /* Let clicks pass through empty areas */
        }

        /* The Anchor: Sits exactly where the canvas center is */
        .center-anchor {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 0;
            height: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto; /* Re-enable clicks for content */
        }

        /* --- HEADERS (Positioned Above Square) --- */
        .header-group {
            position: absolute;
            bottom: 360px; /* Increased from 320px to move it further up above the vines */
            width: 800px;
            text-align: center;
        }

        h1 {
            color: #1a45a0;
            font-size: 3.5rem;
            margin: 0 0 20px 0; /* Increased margin for better separation */
            text-shadow: 2px 2px 0px #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
            font-style: italic;
            white-space: nowrap;
        }

        .subtitle {
            color: #123275;
            font-size: 1.2rem;
            display: inline-block;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 20px;
            border-radius: 20px;
            border: 1px solid #e0e0e0;
        }

        /* --- ORGANIC GRID (Fits inside 600px square) --- */
        .bingo-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
            /* 460px fits comfortably inside the 600px vine square */
            width: 460px; 
            height: 460px;
            position: relative;
        }

        .bingo-cell {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #1a45a0;
            color: #1a45a0;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 2px;
            font-size: 0.65rem; /* Smaller font to fit text in 7x7 */
            line-height: 1.1;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s ease, background 0.2s ease;
            user-select: none;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.1);
            
            /* Organic Borders */
            border-radius: 255px 15px 225px 15px / 15px 225px 15px 255px;
        }

        .bingo-cell:hover {
            transform: scale(1.1);
            background: #fff;
            z-index: 10;
            border-color: #123275;
        }

        /* Selected State */
        .bingo-cell.checked {
            background-color: #1a45a0;
            color: white;
            border-color: #123275;
            box-shadow: inset 1px 1px 3px rgba(0,0,0,0.3);
        }

        .bingo-cell.checked::after {
            content: "âœ“";
            position: absolute;
            font-size: 1.5rem;
            color: rgba(255,255,255,0.4);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-15deg);
        }

        .bingo-cell.center-cell {
            background-color: #123275;
            color: #fff;
            font-size: 0.8rem;
        }

        /* --- CONTROLS (Positioned Below Square) --- */
        .controls {
            position: absolute;
            top: 340px; /* Push down below the square */
            text-align: center;
            width: 100%;
        }

        button.reset-btn {
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #1a45a0;
            color: #1a45a0;
            padding: 8px 25px;
            font-family: 'Playfair Display', serif;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            border-radius: 255px 15px 225px 15px / 15px 225px 15px 255px;
            transition: all 0.3s;
        }

        button.reset-btn:hover {
            background: #1a45a0;
            color: white;
        }

        /* Mobile Scale Adjustment */
        @media (max-width: 600px) {
            /* Scale the whole anchor down to fit mobile screens */
            .center-anchor {
                transform: translate(-50%, -50%) scale(0.65);
            }
            /* Adjust canvas scale via CSS if possible, or accept crop */
        }
    </style>
</head>
<body>

<!-- The Background Canvas -->
<canvas id="patternCanvas"></canvas>

<!-- The Bingo Application -->
<div id="app">
    <div class="center-anchor">
        
        <div class="header-group">
            <h1>Anne's Birthday</h1>
            <div class="subtitle">Pub Crawl Bingo</div>
        </div>
        
        <div class="bingo-grid" id="grid">
            <!-- Cells generated by JS -->
        </div>

        <div class="controls">
            <button class="reset-btn" onclick="resetBingo()">Reset Board</button>
        </div>

    </div>
</div>

<script>
    /* -----------------------------------------------------------
       BINGO LOGIC
       ----------------------------------------------------------- */
    
    const BINGO_TASKS = [
        "Take a shot with Anne", "Spot a cute Dog", "Drink Water!", "ID Check", "Spill a Drink", "Group Selfie", "Toilet Selfie",
        "Eat a Fry", "Hear 'I love this song!'", "Stranger says HBD", "Lose the Group", "Find the Group", "Text an Ex", "Karaoke Moment",
        "Bartender's Choice", "Drink a Stout", "Drink a Lager", "Drink a Cider", "Drink a Cocktail", "Buy Anne a Drink", "Compliment Stranger",
        "Toast Speech", "Glass Break Sound", "Happy Tears", "Piggyback Ride", "SPACE", "High Five Bouncer", "Irish Exit Spotted",
        "Wrong Pub Entered", "Walk in Rain", "One more drink...", "Order Pizza", "Shoe Untied", "Phone Dies", "Borrow Charger",
        "Spot a Mullet", "Wear a Hat", "Someone Trips", "Get a Free Drink", "Jagerbomb!", "Baby Guinness", "Tequila!",
        "Dance Off", "Request a Song", "Hug Anne", "Anne Laughs", "Photo with Anne", "Pet a Pub Dog", "Survive the Night"
    ];

    const STORAGE_KEY = 'anne_bingo_state_v1';

    function loadState() {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
            return JSON.parse(saved);
        }
        const state = new Array(49).fill(false);
        state[25] = true; // Free space always true
        return state;
    }

    function saveState(state) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }

    // Run once on page load to create DOM elements
    function initGrid() {
        const gridEl = document.getElementById('grid');
        gridEl.innerHTML = ''; // Clear initial

        BINGO_TASKS.forEach((task, index) => {
            const cell = document.createElement('div');
            cell.className = 'bingo-cell';
            cell.id = `cell-${index}`; // ID for referencing later
            
            // Calc random shape once
            const r1 = 200 + Math.random() * 55;
            const r2 = 10 + Math.random() * 30;
            const r3 = 200 + Math.random() * 55;
            const r4 = 10 + Math.random() * 30;
            cell.style.borderRadius = `${r1}px ${r2}px ${r3}px ${r4}px / ${r4}px ${r3}px ${r2}px ${r1}px`;

            cell.innerText = task;


            cell.onclick = () => toggleCell(index);
            gridEl.appendChild(cell);
        });

        // Apply visual state after creating
        updateGridUI();
    }

    // Only updates CSS classes, does not rebuild DOM
    function updateGridUI() {
        const state = loadState();
        BINGO_TASKS.forEach((_, index) => {
            const cell = document.getElementById(`cell-${index}`);
            if (state[index]) {
                cell.classList.add('checked');
            } else {
                cell.classList.remove('checked');
            }
        });
    }

    function toggleCell(index) {
        const state = loadState();
        state[index] = !state[index];
        if (index === 25) state[index] = true; // Force center true
        
        saveState(state);
        updateGridUI(); // Update existing cells
    }

    function resetBingo() {
        if(confirm("Are you sure you want to clear the board?")) {
            const state = new Array(49).fill(false);
            state[25] = true;
            saveState(state);
            updateGridUI();
        }
    }

    // Initialize Grid
    initGrid();


    /* -----------------------------------------------------------
       BACKGROUND PATTERN GENERATOR
       ----------------------------------------------------------- */

    const canvas = document.getElementById('patternCanvas');
    const ctx = canvas.getContext('2d');

    // Configuration
    const CONFIG = {
        color: '#1a45a0', // Deep Cobalt
        detailColor: '#123275', // Darker for fine lines
        flowerColor: '#2b5bbd', // Main brush stroke blue
        lineWidth: 0.6, 
        sheetSize: 3000,
        squareSize: 600, // Size of the vine square
        sway: 60, // Curvature of the sides
        layoutSeed: 111, // Seed 111
        skippedElements: [] // Empty list to ensure all flowers are drawn
    };

    // --- Random Generators ---
    let _seed = CONFIG.layoutSeed;
    function layoutRandom() {
        _seed = (_seed * 9301 + 49297) % 233280;
        return _seed / 233280;
    }

    function variationRandom() {
        return Math.random();
    }

    let width, height;
    let placedElements = [];

    function initSheet() {
        width = CONFIG.sheetSize;
        height = CONFIG.sheetSize;
        canvas.width = width;
        canvas.height = height;
        
        _seed = CONFIG.layoutSeed;
        drawPattern();
    }

    function getDistance(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function isOverlapping(x, y, radius) {
        for (const element of placedElements) {
            const dist = getDistance(x, y, element.x, element.y);
            if (dist < element.radius + radius + 15) {
                return true;
            }
        }
        return false;
    }

    // --- Drawing Primitives ---

    function drawLeaf(x, y, angle, scale) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.scale(scale, scale);
        
        ctx.fillStyle = CONFIG.color;
        
        ctx.beginPath();
        ctx.moveTo(0, 0);
        
        const j1 = (variationRandom() - 0.5) * 2;
        const j2 = (variationRandom() - 0.5) * 2;
        
        ctx.bezierCurveTo(5+j1, -4+j2, 10-j1, -6-j2, 15+j1, -3+j2);
        ctx.bezierCurveTo(18-j1, -5-j2, 22+j1, -4+j2, 25, 0); 
        ctx.bezierCurveTo(22-j1, 4-j2, 18+j1, 5+j2, 15-j1, 3-j2);
        ctx.bezierCurveTo(10+j1, 6+j2, 5-j1, 4-j2, 0, 0);
        ctx.fill();
        
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 0.7;
        ctx.beginPath();
        ctx.moveTo(2, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();

        ctx.restore();
    }

    function drawBud(x, y, angle, scale = 1.0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.scale(scale, scale);

        // Stem
        ctx.beginPath();
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = 0.5;
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(5, -2, 10, 0);
        ctx.stroke();

        // Small bud
        ctx.fillStyle = CONFIG.flowerColor;
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.bezierCurveTo(12, -3, 14, -3, 15, 0);
        ctx.bezierCurveTo(14, 3, 12, 3, 10, 0);
        ctx.fill();

        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 0.3;
        ctx.beginPath();
        ctx.moveTo(11, 0); ctx.lineTo(14, 0);
        ctx.stroke();

        const numLeaves = 1 + Math.floor(variationRandom() * 2);
        for(let i=0; i<numLeaves; i++) {
            const t = 0.3 + variationRandom() * 0.4; 
            const lx = (1-t)*(1-t)*0 + 2*(1-t)*t*5 + t*t*10;
            const ly = (1-t)*(1-t)*0 + 2*(1-t)*t*(-2) + t*t*0;
            drawLeaf(lx, ly, angle + (variationRandom()>0.5 ? 0.8:-0.8), 0.3);
        }

        ctx.restore();
    }

    function drawRosette(x, y, angle, scale = 1.0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle); 
        ctx.scale(scale, scale);

        const stemLength = 15;
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = CONFIG.lineWidth;
        
        // Stem
        ctx.beginPath();
        ctx.moveTo(-2, 0); 
        ctx.quadraticCurveTo(stemLength/2, (layoutRandom()-0.5)*4, stemLength, 0);
        ctx.stroke();

        ctx.translate(stemLength, 0);

        const cx = (variationRandom() - 0.5) * 1.5;
        const cy = (variationRandom() - 0.5) * 1.5;

        // Buds
        for(let j=-1; j<=1; j++) {
             const fanAngle = j * 0.6; 
             const startDist = 16; 
             const bx = cx + Math.cos(fanAngle) * startDist;
             const by = cy + Math.sin(fanAngle) * startDist;
             
             ctx.beginPath();
             ctx.lineWidth = 0.5;
             ctx.strokeStyle = CONFIG.color;
             ctx.moveTo(cx, cy);
             ctx.quadraticCurveTo(
                 cx + Math.cos(fanAngle) * (startDist/2), 
                 cy + Math.sin(fanAngle) * (startDist/2) + (j===0?0:(j*2)),
                 bx, by
             );
             ctx.stroke();
             drawBud(bx, by, fanAngle, 0.6);
        }

        // Center
        ctx.fillStyle = CONFIG.detailColor;
        ctx.beginPath();
        ctx.ellipse(cx, cy, 3.5 + (variationRandom()-0.5), 3.5 + (variationRandom()-0.5), variationRandom(), 0, Math.PI*2);
        ctx.fill();

        // Ring
        ctx.strokeStyle = CONFIG.flowerColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        const ringRadius = 6;
        for(let i=0; i<=20; i++) {
            const a = (i/20) * Math.PI*2;
            const r = ringRadius + (variationRandom() - 0.5) * 1.2;
            const px = cx + r * Math.cos(a);
            const py = cy + r * Math.sin(a);
            if(i===0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.stroke();

        // OPTIMIZATION: Calculate all petal properties first to preserve seed order
        const petalCount = 8;
        const petalOffset = Math.PI / 8;
        const petals = [];

        for(let i = 0; i < petalCount; i++) {
            const theta = (i / petalCount) * Math.PI * 2 + petalOffset + (variationRandom() - 0.5) * 0.1;
            const pLen = 7 + (variationRandom() - 0.5) * 2;
            const pWidth = 3.5 + (variationRandom() - 0.5) * 1.5;
            const pRot = (variationRandom()-0.5)*0.2;
            const s1 = (variationRandom() - 0.5);
            const s2 = (variationRandom() - 0.5);
            petals.push({theta, pLen, pWidth, pRot, s1, s2});
        }

        // OPTIMIZATION: Batch draw all petal fills
        ctx.fillStyle = CONFIG.flowerColor;
        ctx.beginPath();
        petals.forEach(p => {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(p.theta);
            ctx.moveTo(11 + p.pLen, 0); // approx move to avoids lines between petals
            ctx.ellipse(11, 0, p.pLen, p.pWidth, p.pRot, 0, Math.PI * 2);
            ctx.restore();
        });
        ctx.fill();

        // OPTIMIZATION: Batch draw all petal details
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        petals.forEach(p => {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(p.theta);
            ctx.moveTo(5+p.s1, 0+p.s2); ctx.lineTo(13-p.s1, 0-p.s2);
            ctx.moveTo(6+p.s2, 1.2+p.s1); ctx.lineTo(11-p.s2, 1.8-p.s1);
            ctx.moveTo(6-p.s1, -1.2-p.s2); ctx.lineTo(11+p.s1, -1.8+p.s2);
            ctx.restore();
        });
        ctx.stroke();

        ctx.restore();
    }

    function drawPalmette(x, y, angle, scale = 1.0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.scale(scale, scale);

        const stemLength = 10; 
        
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = CONFIG.lineWidth;
        ctx.beginPath();
        ctx.moveTo(-2, 0); 
        ctx.quadraticCurveTo(stemLength/2, (layoutRandom()-0.5)*2, stemLength + 1, 0);
        ctx.stroke();

        ctx.translate(stemLength, 0);

        // Base
        ctx.fillStyle = CONFIG.color;
        ctx.beginPath();
        ctx.ellipse(0, 0, 3.5 + (variationRandom()-0.5), 3.5 + (variationRandom()-0.5), variationRandom(), 0, Math.PI*2);
        ctx.fill();

        // OPTIMIZATION: Pre-calculate fan petals
        const fanParts = [];
        for(let i = -2; i <= 2; i++) {
            const theta = i * 0.45 + (variationRandom() - 0.5) * 0.2;
            const jx = (variationRandom() - 0.5) * 3;
            const jy = (variationRandom() - 0.5) * 3;
            fanParts.push({theta, jx, jy});
        }

        // Batch Fills
        ctx.fillStyle = CONFIG.flowerColor;
        ctx.beginPath();
        fanParts.forEach(p => {
            ctx.save();
            ctx.rotate(p.theta);
            ctx.moveTo(0,0);
            ctx.quadraticCurveTo(6+p.jx, -4+p.jy, 16-p.jx, -3-p.jy);
            ctx.quadraticCurveTo(18+p.jx, 0+p.jy, 16-p.jx, 3+p.jy);
            ctx.quadraticCurveTo(6+p.jx, 4-p.jy, 0, 0);
            ctx.restore();
        });
        ctx.fill();

        // Batch Strokes
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        fanParts.forEach(p => {
            ctx.save();
            ctx.rotate(p.theta);
            ctx.moveTo(4,0); ctx.lineTo(14+p.jx,0);
            ctx.restore();
        });
        ctx.stroke();

        ctx.restore();
    }

    function drawBranch(x, y, length, angle, depth) {
        if (depth <= 0) {
            if(layoutRandom() > 0.5) drawRosette(x, y, angle, 0.7);
            else drawPalmette(x, y, angle - Math.PI/2, 0.7);
            return;
        }

        const endX = x + Math.cos(angle) * length;
        const endY = y + Math.sin(angle) * length;

        ctx.beginPath();
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = Math.max(0.3, CONFIG.lineWidth * (depth / 1.5)); 
        
        const ctrlX = (x + endX) / 2 + (layoutRandom() - 0.5) * 20;
        const ctrlY = (y + endY) / 2 + (layoutRandom() - 0.5) * 20;
        
        ctx.quadraticCurveTo(ctrlX, ctrlY, endX, endY);
        ctx.stroke();

        drawBranch(endX, endY, length * 0.7, angle + (layoutRandom() - 0.5) * 1.0, depth - 1);
    }

    function drawDecoratedSide(x1, y1, x2, y2, curvatureDirection, sideIndex) {
        ctx.beginPath();
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = CONFIG.lineWidth;
        
        const dx = x2 - x1;
        const dy = y2 - y1;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const midX = (x1 + x2) / 2;
        const midY = (x1 + y2) / 2;

        let perpX = -dy / dist;
        let perpY = dx / dist;

        perpX *= curvatureDirection;
        perpY *= curvatureDirection;
        
        const swayAmount = CONFIG.sway;
        const cp1x = midX + perpX * swayAmount;
        const cp1y = midY + perpY * swayAmount;

        ctx.moveTo(x1, y1);
        ctx.quadraticCurveTo(cp1x, cp1y, x2, y2);
        ctx.stroke();

        const numElements = 8; 
        
        for(let i = 0; i < numElements; i++) {
            const segmentSize = 1.0 / numElements;
            const t = (i * segmentSize) + (layoutRandom() * segmentSize * 0.8) + (segmentSize * 0.1);

            const bx = (1-t)*(1-t)*x1 + 2*(1-t)*t*cp1x + t*t*x2;
            const by = (1-t)*(1-t)*y1 + 2*(1-t)*t*cp1y + t*t*y2;

            const tx = 2*(1-t)*(cp1x - x1) + 2*t*(x2 - cp1x);
            const ty = 2*(1-t)*(cp1y - y1) + 2*t*(y2 - cp1y);
            const tangentAngle = Math.atan2(ty, tx);

            const type = layoutRandom();
        
            if (type > 0.55) {
                const scale = 0.9 + layoutRandom() * 0.3;
                const radius = 25 * scale; 
                const flip = layoutRandom() > 0.5 ? 1 : -1; 
                
                if (!isOverlapping(bx, by, radius)) {
                    placedElements.push({x: bx, y: by, radius: radius});
                    drawRosette(bx, by, tangentAngle + (Math.PI/2 * flip), scale);
                }
            } else if (type > 0.25) {
                const scale = 0.8 + layoutRandom() * 0.2;
                const radius = 18 * scale; 
                const flip = layoutRandom() > 0.5 ? 1 : -1;
                
                if (!isOverlapping(bx, by, radius)) {
                    placedElements.push({x: bx, y: by, radius: radius});
                    drawPalmette(bx, by, tangentAngle - (Math.PI/2 * flip), scale);
                }
            } else {
                drawBranch(bx, by, 30, tangentAngle + (layoutRandom() > 0.5 ? 1.2 : -1.2), 1);
            }
        }
    }

    function drawPattern() {
        placedElements = [];

        ctx.fillStyle = '#ffffff'; 
        ctx.fillRect(0, 0, width, height);

        ctx.strokeStyle = '#f8f9fa';
        ctx.lineWidth = 1.2;
        for(let x = 0; x < width; x += 14) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke();
        }

        const cx = width / 2; 
        const cy = height / 2;
        const size = CONFIG.squareSize;

        const corners = [
            { x: cx - size/2, y: cy - size/2 }, // Top Left
            { x: cx + size/2, y: cy - size/2 }, // Top Right
            { x: cx + size/2, y: cy + size/2 }, // Bottom Right
            { x: cx - size/2, y: cy + size/2 }  // Bottom Left
        ];
        
        corners.forEach((corner, index) => {
            const cornerAngle = (index * Math.PI/2) - 3*Math.PI/4;
            const scale = 0.9;
            placedElements.push({x: corner.x, y: corner.y, radius: 28 * scale});
            drawRosette(corner.x, corner.y, cornerAngle, scale);
        });

        drawDecoratedSide(corners[0].x, corners[0].y, corners[1].x, corners[1].y, -1); 
        drawDecoratedSide(corners[1].x, corners[1].y, corners[2].x, corners[2].y, -1); 
        drawDecoratedSide(corners[2].x, corners[2].y, corners[3].x, corners[3].y, -1); 
        drawDecoratedSide(corners[3].x, corners[3].y, corners[0].x, corners[0].y, -1); 
    }

    requestAnimationFrame(initSheet);

</script>
</body>
</html>
