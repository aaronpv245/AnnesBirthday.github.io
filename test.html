<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anne's Birthday Bingo</title>
    <!-- Import a font that matches the Royal Copenhagen vibe -->
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #ffffff;
            font-family: 'Playfair Display', serif;
            overflow: hidden; /* We handle scaling manually */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* --- THE SCALING CONTAINER --- 
           Everything lives in here. We design for a fixed "Base Resolution"
           of roughly 1000px x 1000px, and then JS scales this entire div 
           to fit the screen. 
        */
        #main-container {
            position: relative;
            width: 1000px;
            height: 1000px;
            display: flex;
            align-items: center;
            justify-content: center;
            transform-origin: center center;
        }

        /* --- BACKGROUND CANVAS --- 
           Now absolute INSIDE the container so it scales with it.
        */
        canvas {
            display: block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 0;
            pointer-events: none; 
        }

        /* --- HEADERS (Positioned relative to container center) --- */
        .header-group {
            position: absolute;
            /* Positioned above the 600px vine square (which starts at y=200px relative to container) */
            top: 30px; 
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            text-align: center;
            z-index: 2;
        }

        h1 {
            color: #1a45a0;
            font-size: 4rem;
            margin: 0 0 5px 0; /* Reduced margin to pull subtitle up closer */
            text-shadow: 3px 3px 0px #fff, -1px -1px 0 #fff;
            font-style: italic;
            white-space: nowrap;
        }

        .subtitle {
            color: #123275;
            font-size: 1.5rem;
            display: inline-block;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 30px;
            border-radius: 30px;
            border: 1px solid #e0e0e0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        /* --- ORGANIC GRID --- */
        .bingo-grid {
            position: absolute;
            /* Centering the grid perfectly in the container */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            /* 460px fits inside the 600px vine square */
            width: 460px; 
            height: 460px;
        }

        .bingo-cell {
            background: rgba(255, 255, 255, 0.92);
            border: 1.5px solid #1a45a0;
            color: #1a45a0;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 2px;
            font-size: 0.7rem; 
            line-height: 1.1;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.15s ease, background 0.15s ease;
            user-select: none;
            box-shadow: 2px 2px 4px rgba(26, 69, 160, 0.15);
            /* Initial organic radius - JS adds variety */
            border-radius: 15px; 
        }

        .bingo-cell:hover {
            transform: scale(1.15);
            background: #fff;
            z-index: 10;
            border-color: #123275;
            box-shadow: 4px 4px 8px rgba(26, 69, 160, 0.25);
        }

        /* Selected State */
        .bingo-cell.checked {
            background-color: #1a45a0;
            color: white;
            border-color: #123275;
            box-shadow: inset 1px 1px 3px rgba(0,0,0,0.3);
        }

        .bingo-cell.checked::after {
            content: "âœ“";
            position: absolute;
            font-size: 1.8rem;
            color: rgba(255,255,255,0.5);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-10deg);
        }

        .bingo-cell.center-cell {
            font-size: 0.85rem;
        }

        /* --- CONTROLS --- */
        .controls {
            position: absolute;
            /* Pushes button down below the grid and vines */
            top: 50%;
            margin-top: 400px; 
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 2;
            width: 100%;
        }

        button.reset-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #1a45a0;
            color: #1a45a0;
            padding: 12px 35px;
            font-family: 'Playfair Display', serif;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            border-radius: 255px 15px 225px 15px / 15px 225px 15px 255px;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        button.reset-btn:hover {
            background: #1a45a0;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.15);
        }

    </style>
</head>
<body>

<!-- Unified Container for Scaling -->
<div id="main-container">
    
    <!-- Background Pattern -->
    <canvas id="patternCanvas"></canvas>

    <!-- Headers -->
    <div class="header-group">
        <h1>Anne's Birthday</h1>
        <div class="subtitle">Pub Crawl Bingo</div>
    </div>
    
    <!-- Grid -->
    <div class="bingo-grid" id="grid"></div>

    <!-- Controls -->
    <div class="controls">
        <button class="reset-btn" onclick="resetBingo()">Reset Board</button>
    </div>

</div>

<script>
    /* -----------------------------------------------------------
       SCALING LOGIC
       ----------------------------------------------------------- */
    const container = document.getElementById('main-container');
    
    function resizeApp() {
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const targetWidth = 1000; // Our base design width
        const targetHeight = 1000; // Our base design height

        // Determine scale to fit within viewport with some padding
        const scaleX = (windowWidth - 20) / targetWidth;
        const scaleY = (windowHeight - 20) / targetHeight;
        const scale = Math.min(scaleX, scaleY); // Fit to smallest dimension

        container.style.transform = `scale(${scale})`;
    }

    window.addEventListener('resize', resizeApp);
    resizeApp(); // Trigger immediately


    /* -----------------------------------------------------------
       BINGO LOGIC
       ----------------------------------------------------------- */
    
    const BINGO_TASKS = [
        "Take a shot with Anne", "Spot a cute Dog", "Drink Water!", "ID Check", "Spill a Drink", "Group Selfie", "Toilet Selfie",
        "Eat a Fry", "Hear 'I love this song!'", "Stranger says HBD", "Lose the Group", "Find the Group", "Text an Ex", "Karaoke Moment",
        "Bartender's Choice", "Drink a Stout", "Drink a Lager", "Drink a Cider", "Drink a Cocktail", "Buy Anne a Drink", "Compliment Stranger",
        "Toast Speech", "Glass Break Sound", "Happy Tears", "Piggyback Ride", "Propose a Toast", "High Five Bouncer", "Irish Exit Spotted",
        "Wrong Pub Entered", "Walk in Rain", "One more drink...", "Order Pizza", "Shoe Untied", "Phone Dies", "Borrow Charger",
        "Spot a Mullet", "Wear a Hat", "Someone Trips", "Get a Free Drink", "Jagerbomb!", "Baby Guinness", "Tequila!",
        "Dance Off", "Request a Song", "Hug Anne", "Anne Laughs", "Photo with Anne", "Pet a Pub Dog", "Survive the Night"
    ];

    const STORAGE_KEY = 'anne_bingo_state_v2';

    function loadState() {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
            return JSON.parse(saved);
        }
        return new Array(49).fill(false);
    }

    function saveState(state) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }

    function initGrid() {
        const gridEl = document.getElementById('grid');
        gridEl.innerHTML = '';

        BINGO_TASKS.forEach((task, index) => {
            const cell = document.createElement('div');
            cell.className = 'bingo-cell';
            cell.id = `cell-${index}`;
            
            // Generate Organic Shape
            const r1 = 200 + Math.random() * 55;
            const r2 = 10 + Math.random() * 30;
            const r3 = 200 + Math.random() * 55;
            const r4 = 10 + Math.random() * 30;
            cell.style.borderRadius = `${r1}px ${r2}px ${r3}px ${r4}px / ${r4}px ${r3}px ${r2}px ${r1}px`;

            cell.innerText = task;

            if (index === 24) { 
                cell.classList.add('center-cell');
            }

            cell.onclick = () => toggleCell(index);
            gridEl.appendChild(cell);
        });

        updateGridUI();
    }

    function updateGridUI() {
        const state = loadState();
        BINGO_TASKS.forEach((_, index) => {
            const cell = document.getElementById(`cell-${index}`);
            if (state[index]) {
                cell.classList.add('checked');
            } else {
                cell.classList.remove('checked');
            }
        });
    }

    function toggleCell(index) {
        const state = loadState();
        state[index] = !state[index];
        saveState(state);
        updateGridUI();
    }

    function resetBingo() {
        if(confirm("Are you sure you want to clear the board and reset progress?")) {
            // Clear specific key
            localStorage.removeItem(STORAGE_KEY);
            // OR clear all if requested: localStorage.clear();
            
            updateGridUI(); // Will revert to default false state
        }
    }

    initGrid();


    /* -----------------------------------------------------------
       BACKGROUND PATTERN GENERATOR
       ----------------------------------------------------------- */

    const canvas = document.getElementById('patternCanvas');
    const ctx = canvas.getContext('2d');

    // Configuration
    const CONFIG = {
        color: '#1a45a0', 
        detailColor: '#123275',
        flowerColor: '#2b5bbd', 
        lineWidth: 0.6, 
        sheetSize: 3000,
        squareSize: 600, 
        sway: 60,
        layoutSeed: 111,
        skippedElements: []
    };

    let _seed = CONFIG.layoutSeed;
    function layoutRandom() {
        _seed = (_seed * 9301 + 49297) % 233280;
        return _seed / 233280;
    }

    function variationRandom() {
        return Math.random();
    }

    let width, height;
    let placedElements = [];

    function initSheet() {
        // High DPI Support
        // Cap DPR at 2 to avoid creating excessively large canvases on super-high-res devices
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        
        // Logical Dimensions
        width = CONFIG.sheetSize;
        height = CONFIG.sheetSize;
        
        // Set physical size (pixels)
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        
        // Set display size (css)
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        
        // Scale drawing context to match
        ctx.scale(dpr, dpr);
        
        _seed = CONFIG.layoutSeed;
        drawPattern();
    }

    function getDistance(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function isOverlapping(x, y, radius) {
        for (const element of placedElements) {
            const dist = getDistance(x, y, element.x, element.y);
            if (dist < element.radius + radius + 15) {
                return true;
            }
        }
        return false;
    }

    // --- Drawing Primitives (Preserved from optimized version) ---

    function drawLeaf(x, y, angle, scale) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.scale(scale, scale);
        
        ctx.fillStyle = CONFIG.color;
        
        ctx.beginPath();
        ctx.moveTo(0, 0);
        
        const j1 = (variationRandom() - 0.5) * 2;
        const j2 = (variationRandom() - 0.5) * 2;
        
        ctx.bezierCurveTo(5+j1, -4+j2, 10-j1, -6-j2, 15+j1, -3+j2);
        ctx.bezierCurveTo(18-j1, -5-j2, 22+j1, -4+j2, 25, 0); 
        ctx.bezierCurveTo(22-j1, 4-j2, 18+j1, 5+j2, 15-j1, 3-j2);
        ctx.bezierCurveTo(10+j1, 6+j2, 5-j1, 4-j2, 0, 0);
        ctx.fill();
        
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 0.7;
        ctx.beginPath();
        ctx.moveTo(2, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();

        ctx.restore();
    }

    function drawBud(x, y, angle, scale = 1.0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.scale(scale, scale);

        const ctrlX = 5 + (variationRandom() - 0.5) * 4;
        const ctrlY = -2 + (variationRandom() - 0.5) * 4;

        ctx.beginPath();
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = 0.5;
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(ctrlX, ctrlY, 10, 0);
        ctx.stroke();

        const budTip = 15 + (variationRandom() - 0.5) * 2; 
        const budWidth = 3 + (variationRandom() - 0.5) * 1.5; 
        
        ctx.fillStyle = CONFIG.flowerColor;
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.bezierCurveTo(12, -budWidth, 14, -budWidth, budTip, 0);
        ctx.bezierCurveTo(14, budWidth, 12, budWidth, 10, 0);
        ctx.fill();

        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 0.3;
        ctx.beginPath();
        ctx.moveTo(11, 0); ctx.lineTo(budTip - 1, 0);
        ctx.stroke();

        const numLeaves = 1 + Math.floor(variationRandom() * 2);
        for(let i=0; i<numLeaves; i++) {
            const t = 0.3 + variationRandom() * 0.4; 
            const mt = 1-t;
            const lx = mt*mt*0 + 2*mt*t*ctrlX + t*t*10;
            const ly = mt*mt*0 + 2*mt*t*ctrlY + t*t*0;
            drawLeaf(lx, ly, angle + (variationRandom()>0.5 ? 0.8:-0.8), 0.3);
        }

        ctx.restore();
    }

    function drawRosette(x, y, angle, scale = 1.0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle); 
        ctx.scale(scale, scale);

        const stemLength = 15;
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = CONFIG.lineWidth;
        
        ctx.beginPath();
        ctx.moveTo(-2, 0); 
        ctx.quadraticCurveTo(stemLength/2, (layoutRandom()-0.5)*4, stemLength, 0);
        ctx.stroke();

        ctx.translate(stemLength, 0);

        const cx = (variationRandom() - 0.5) * 1.5;
        const cy = (variationRandom() - 0.5) * 1.5;

        for(let j=-1; j<=1; j++) {
             const fanAngle = j * 0.6; 
             const startDist = 16; 
             const bx = cx + Math.cos(fanAngle) * startDist;
             const by = cy + Math.sin(fanAngle) * startDist;
             
             ctx.beginPath();
             ctx.lineWidth = 0.5;
             ctx.strokeStyle = CONFIG.color;
             ctx.moveTo(cx, cy);
             ctx.quadraticCurveTo(
                 cx + Math.cos(fanAngle) * (startDist/2), 
                 cy + Math.sin(fanAngle) * (startDist/2) + (j===0?0:(j*2)),
                 bx, by
             );
             ctx.stroke();
             drawBud(bx, by, fanAngle, 0.6);
        }

        ctx.fillStyle = CONFIG.detailColor;
        ctx.beginPath();
        ctx.ellipse(cx, cy, 3.5 + (variationRandom()-0.5), 3.5 + (variationRandom()-0.5), variationRandom(), 0, Math.PI*2);
        ctx.fill();

        ctx.strokeStyle = CONFIG.flowerColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        const ringRadius = 6;
        for(let i=0; i<=20; i++) {
            const a = (i/20) * Math.PI*2;
            const r = ringRadius + (variationRandom() - 0.5) * 1.2;
            const px = cx + r * Math.cos(a);
            const py = cy + r * Math.sin(a);
            if(i===0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.stroke();

        // OPTIMIZATION: Calculate all petal properties first to preserve seed order
        const petalCount = 8;
        const petalOffset = Math.PI / 8;
        const petals = [];

        for(let i = 0; i < petalCount; i++) {
            const theta = (i / petalCount) * Math.PI * 2 + petalOffset + (variationRandom() - 0.5) * 0.1;
            const pLen = 7 + (variationRandom() - 0.5) * 2;
            const pWidth = 3.5 + (variationRandom() - 0.5) * 1.5;
            const pRot = (variationRandom()-0.5)*0.2;
            const s1 = (variationRandom() - 0.5);
            const s2 = (variationRandom() - 0.5);
            petals.push({theta, pLen, pWidth, pRot, s1, s2});
        }

        // OPTIMIZATION: Batch draw all petal fills
        ctx.fillStyle = CONFIG.flowerColor;
        ctx.beginPath();
        petals.forEach(p => {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(p.theta);
            ctx.moveTo(11 + p.pLen, 0); // approx move to avoids lines between petals
            ctx.ellipse(11, 0, p.pLen, p.pWidth, p.pRot, 0, Math.PI * 2);
            ctx.restore();
        });
        ctx.fill();

        // OPTIMIZATION: Batch draw all petal details
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        petals.forEach(p => {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(p.theta);
            ctx.moveTo(5+p.s1, 0+p.s2); ctx.lineTo(13-p.s1, 0-p.s2);
            ctx.moveTo(6+p.s2, 1.2+p.s1); ctx.lineTo(11-p.s2, 1.8-p.s1);
            ctx.moveTo(6-p.s1, -1.2-p.s2); ctx.lineTo(11+p.s1, -1.8+p.s2);
            ctx.restore();
        });
        ctx.stroke();

        ctx.restore();
    }

    function drawPalmette(x, y, angle, scale = 1.0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.scale(scale, scale);

        const stemLength = 10; 
        
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = CONFIG.lineWidth;
        ctx.beginPath();
        ctx.moveTo(-2, 0); 
        ctx.quadraticCurveTo(stemLength/2, (layoutRandom()-0.5)*2, stemLength + 1, 0);
        ctx.stroke();

        ctx.translate(stemLength, 0);

        // Base
        ctx.fillStyle = CONFIG.color;
        ctx.beginPath();
        ctx.ellipse(0, 0, 3.5 + (variationRandom()-0.5), 3.5 + (variationRandom()-0.5), variationRandom(), 0, Math.PI*2);
        ctx.fill();

        // OPTIMIZATION: Pre-calculate fan petals
        const fanParts = [];
        for(let i = -2; i <= 2; i++) {
            const theta = i * 0.45 + (variationRandom() - 0.5) * 0.2;
            const jx = (variationRandom() - 0.5) * 3;
            const jy = (variationRandom() - 0.5) * 3;
            fanParts.push({theta, jx, jy});
        }

        // Batch Fills
        ctx.fillStyle = CONFIG.flowerColor;
        ctx.beginPath();
        fanParts.forEach(p => {
            ctx.save();
            ctx.rotate(p.theta);
            ctx.moveTo(0,0);
            ctx.quadraticCurveTo(6+p.jx, -4+p.jy, 16-p.jx, -3-p.jy);
            ctx.quadraticCurveTo(18+p.jx, 0+p.jy, 16-p.jx, 3+p.jy);
            ctx.quadraticCurveTo(6+p.jx, 4-p.jy, 0, 0);
            ctx.restore();
        });
        ctx.fill();

        // Batch Strokes
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        fanParts.forEach(p => {
            ctx.save();
            ctx.rotate(p.theta);
            ctx.moveTo(4,0); ctx.lineTo(14+p.jx,0);
            ctx.restore();
        });
        ctx.stroke();

        ctx.restore();
    }

    function drawBranch(x, y, length, angle, depth) {
        if (depth <= 0) {
            if(layoutRandom() > 0.5) drawRosette(x, y, angle, 0.7);
            else drawPalmette(x, y, angle - Math.PI/2, 0.7);
            return;
        }

        const endX = x + Math.cos(angle) * length;
        const endY = y + Math.sin(angle) * length;

        ctx.beginPath();
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = Math.max(0.3, CONFIG.lineWidth * (depth / 1.5)); 
        
        const ctrlX = (x + endX) / 2 + (layoutRandom() - 0.5) * 20;
        const ctrlY = (y + endY) / 2 + (layoutRandom() - 0.5) * 20;
        
        ctx.quadraticCurveTo(ctrlX, ctrlY, endX, endY);
        ctx.stroke();

        drawBranch(endX, endY, length * 0.7, angle + (layoutRandom() - 0.5) * 1.0, depth - 1);
    }

    function drawDecoratedSide(x1, y1, x2, y2, curvatureDirection, sideIndex) {
        ctx.beginPath();
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = CONFIG.lineWidth;
        
        const dx = x2 - x1;
        const dy = y2 - y1;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const midX = (x1 + x2) / 2;
        const midY = (x1 + y2) / 2;

        let perpX = -dy / dist;
        let perpY = dx / dist;

        perpX *= curvatureDirection;
        perpY *= curvatureDirection;
        
        const swayAmount = CONFIG.sway;
        const cp1x = midX + perpX * swayAmount;
        const cp1y = midY + perpY * swayAmount;

        ctx.moveTo(x1, y1);
        ctx.quadraticCurveTo(cp1x, cp1y, x2, y2);
        ctx.stroke();

        const numElements = 8; 
        
        for(let i = 0; i < numElements; i++) {
            const segmentSize = 1.0 / numElements;
            const t = (i * segmentSize) + (layoutRandom() * segmentSize * 0.8) + (segmentSize * 0.1);

            const bx = (1-t)*(1-t)*x1 + 2*(1-t)*t*cp1x + t*t*x2;
            const by = (1-t)*(1-t)*y1 + 2*(1-t)*t*cp1y + t*t*y2;

            const tx = 2*(1-t)*(cp1x - x1) + 2*t*(x2 - cp1x);
            const ty = 2*(1-t)*(cp1y - y1) + 2*t*(y2 - cp1y);
            const tangentAngle = Math.atan2(ty, tx);

            const type = layoutRandom();
        
            if (type > 0.55) {
                const scale = 0.9 + layoutRandom() * 0.3;
                const radius = 25 * scale; 
                const flip = layoutRandom() > 0.5 ? 1 : -1; 
                
                if (!isOverlapping(bx, by, radius)) {
                    placedElements.push({x: bx, y: by, radius: radius});
                    drawRosette(bx, by, tangentAngle + (Math.PI/2 * flip), scale);
                }
            } else if (type > 0.25) {
                const scale = 0.8 + layoutRandom() * 0.2;
                const radius = 18 * scale; 
                const flip = layoutRandom() > 0.5 ? 1 : -1;
                
                if (!isOverlapping(bx, by, radius)) {
                    placedElements.push({x: bx, y: by, radius: radius});
                    drawPalmette(bx, by, tangentAngle - (Math.PI/2 * flip), scale);
                }
            } else {
                drawBranch(bx, by, 30, tangentAngle + (layoutRandom() > 0.5 ? 1.2 : -1.2), 1);
            }
        }
    }

    function drawPattern() {
        placedElements = [];

        // Note: Canvas clears automatically when redrawn or initialized usually, 
        // but explicit clear is good practice if resizing/redrawing often
        ctx.fillStyle = '#ffffff'; 
        ctx.fillRect(0, 0, width, height);

        ctx.strokeStyle = '#f8f9fa';
        ctx.lineWidth = 1.2;
        for(let x = 0; x < width; x += 14) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke();
        }

        // Draw Pattern centered in the massive sheet
        const cx = width / 2; 
        const cy = height / 2;
        const size = CONFIG.squareSize;

        const corners = [
            { x: cx - size/2, y: cy - size/2 }, // Top Left
            { x: cx + size/2, y: cy - size/2 }, // Top Right
            { x: cx + size/2, y: cy + size/2 }, // Bottom Right
            { x: cx - size/2, y: cy + size/2 }  // Bottom Left
        ];
        
        corners.forEach((corner, index) => {
            const cornerAngle = (index * Math.PI/2) - 3*Math.PI/4;
            const scale = 0.9;
            placedElements.push({x: corner.x, y: corner.y, radius: 28 * scale});
            drawRosette(corner.x, corner.y, cornerAngle, scale);
        });

        drawDecoratedSide(corners[0].x, corners[0].y, corners[1].x, corners[1].y, -1); 
        drawDecoratedSide(corners[1].x, corners[1].y, corners[2].x, corners[2].y, -1); 
        drawDecoratedSide(corners[2].x, corners[2].y, corners[3].x, corners[3].y, -1); 
        drawDecoratedSide(corners[3].x, corners[3].y, corners[0].x, corners[0].y, -1); 
    }

    // Start
    requestAnimationFrame(initSheet);

</script>
</body>
</html>